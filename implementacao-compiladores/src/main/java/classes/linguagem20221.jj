options {
    //IGNORE_CASE = true;
    JAVA_UNICODE_ESCAPE = true;
    STATIC = false;
    DEBUG_PARSER = true;
    LOOKAHEAD = 1;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Language20221)
package classes;

import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.lang.StringBuilder;
import maquinavirtual.InstructionK;

public class Language20221{
    private StringBuilder tokens = new StringBuilder();
    private List<String> lexicalErrors = new ArrayList<String>();
    private Boolean hasLexicalErrors = false;
    private int contLexicalErrors = 0;
    static List<ErrorStruct> syntaticsErrors = new ArrayList<ErrorStruct>();
    private List<String> semanticErrors = new ArrayList<String>();
    public LanguageRules acoesSemanticas = new LanguageRules();
    boolean debugRecovery = true;
    boolean eof;
    private int contSyntaticsErrors = 0;
    private List<InstructionK> instructionList;

    public void leituraDeTokens()  {
        contLexicalErrors = 0;
        contSyntaticsErrors = 0;
        for(int i = 0 ; i < syntaticsErrors.size(); i++){
            syntaticsErrors.remove(i);
        }
        try {
            Token t = null;
            t = getNextToken();
            if (t.kind == EOF) return;
            //System.out.println("KIND DO TOKEN LIDO: " + t.kind);
            switch(t.kind){
                case PALAVRA_RESERVADA_ALL        :
                case PALAVRA_RESERVADA_AND        :
                case PALAVRA_RESERVADA_AS         :
                case PALAVRA_RESERVADA_AVALIATE   :
                case PALAVRA_RESERVADA_BODY       :
                case PALAVRA_RESERVADA_CONSTANT   :
                case PALAVRA_RESERVADA_DECLARATION:
                case PALAVRA_RESERVADA_DESCRIPTION:
                case PALAVRA_RESERVADA_DESIGNATE  :
                case PALAVRA_RESERVADA_DO         :
                case PALAVRA_RESERVADA_INTEGER    :
                case PALAVRA_RESERVADA_IS         :
                case PALAVRA_RESERVADA_LOGIC      :
                case PALAVRA_RESERVADA_READ       :
                case PALAVRA_RESERVADA_REAL       :
                case PALAVRA_RESERVADA_REPEAT     :
                case PALAVRA_RESERVADA_RESULT     :
                case PALAVRA_RESERVADA_STRING     :
                case PALAVRA_RESERVADA_THIS       :
                case PALAVRA_RESERVADA_TRUE       :
                case PALAVRA_RESERVADA_TYPE       :
                case PALAVRA_RESERVADA_UNTRUE     :
                case PALAVRA_RESERVADA_VARIABLE   :
                case PALAVRA_RESERVADA_WRITE      :
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'PALAVRA-RESERVADA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'PALAVRA-RESERVADA' -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case IDENTIFICADOR:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'IDENTIFICADOR'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'IDENTIFICADOR'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "']\n");
                    break;
                }
                case CONSTANTE_LITERAL:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'CONSTANTE_LITERAL'  -  " + "Id: ['" +  t.kind + "'] - Linha: ['" + t.beginLine + "']  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case CONSTANTE_NUMERICA_INTEIRA:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'CONSTANTE_NUMERICA_INTEIRA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case CONSTANTE_NUMERICA_REAL:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'CONSTANTE_NUMERICA_REAL'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                //Símbolos especiais
                case SIMBOLO_ESPECIAL_ABRE_CHAVES:
                case SIMBOLO_ESPECIAL_FECHA_CHAVES:
                case SIMBOLO_ESPECIAL_PONTO_FINAL:
                case SIMBOLO_ESPECIAL_VIRGULA:
                case SIMBOLO_ESPECIAL_ABRE_COLCHETES:
                case SIMBOLO_ESPECIAL_FECHA_COLCHETES:
                case SIMBOLO_ESPECIAL_ABRE_PARENTESES:
                case SIMBOLO_ESPECIAL_FECHA_PARENTESES:
                //Símbolos aritméticos
                case OPERADOR_ARITMETICO_ADICAO:
                case OPERADOR_ARITMETICO_SUBTRACAO:
                case OPERADOR_ARITMETICO_MULTIPLICACAO:
                case OPERADOR_ARITMETICO_DIVISAO:
                case OPERADOR_ARITMETICO_POTENCIACAO:
                case OPERADOR_ARITMETICO_DIVISAO_INTEIRA:
                case OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA:
                //Símbolos lógicos
                case OPERADOR_RELACIONAL_IGUAL:
                case OPERADOR_RELACIONAL_DIFERENTE:
                case OPERADOR_RELACIONAL_MENOR:
                case OPERADOR_RELACIONAL_MAIOR:
                case OPERADOR_RELACIONAL_MENOR_IGUAL:
                case OPERADOR_RELACIONAL_MAIOR_IGUAL:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'SIMBOLO_ESPECIAL'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'SIMBOLO_ESPECIAL'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case SIMBOLO_INVALIDO:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'SIMBOLO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.add("Erro: '" + t.image + "' - Tipo: 'SIMBOLO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'SIMBOLO_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case CONSTANTE_LITERAL_INVALIDA:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.add("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL_INVALIDA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case CONSTANTE_NUMERICA_INTEIRA_INVALIDA:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.add("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA_INVALIDA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case CONSTANTE_NUMERICA_REAL_INVALIDA:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.add("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL_INVALIDA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case COMENTARIO_FACULTATIVO_INVALIDO:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'COMENTARIO_FACULTATIVO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.add("Erro: '" + t.image + "' - Tipo: 'COMENTARIO_FACULTATIVO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'COMENTARIO_FACULTATIVO_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                 case IDENTIFICADOR_INVALIDO:
                 {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.add("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                 }
                /*default:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    break;
                }*/
            }
            leituraDeTokens();
        }catch(Error erro){
            hasLexicalErrors = true;
            contLexicalErrors++;
            tokens.append("Erro - " + erro.getMessage() + "\n");
            System.out.println(erro.toString());
            leituraDeTokens();
        }
    }

    public List<InstructionK> getInstructions() {
        return this.instructionList;
    }

    public String analyze(String args[], String textToAnalyze) throws ParseException  {
        Language20221 language20221 = this.readInput(args, textToAnalyze);
        StringBuilder errosLexicos = new StringBuilder("");
        StringBuilder errosSintaticos = new StringBuilder("");
        StringBuilder errosSemanticos = new StringBuilder("");

        this.leituraDeTokens();
        tokens.append("<EOF>");

        try {
            if(!hasLexicalErrors){
                language20221.begin_program();
            } else {
                language20221 = null;
                errosLexicos.append(errorListToString("Lexic errors found!", lexicalErrors));
                return lexicalErrors.toString();
            }
        }catch (ParseException ex) {
            return ex.getMessage().toString();
        }
        if(language20221.getContSyntaticsErrors() > 0){
             errosSintaticos.append("\n");
             errosSintaticos.append(syntaticsErrors.size() + " Erros sintaticos encontrados :\n");
             for (ErrorStruct err: syntaticsErrors){
                 errosSintaticos.append(err.getMsg());
                 errosSintaticos.append("Esperado(s):" + err.expected());
                 errosSintaticos.append("Linha: " + err.getError().currentToken.beginLine);
                 errosSintaticos.append("; Coluna: " + err.getError().currentToken.endColumn + "\n");
             }
             language20221 = null;
             return errosSintaticos.toString();
        }
        errosSintaticos.append("Sintaticamente correto!");

        this.semanticErrors = acoesSemanticas.getListaErros();
        if (semanticErrors.size() > 0) {
            errosSemanticos.append(errorListToString("Semantic errors found!", semanticErrors));
            language20221 = null;
            return errosSemanticos.toString();
        }
        this.instructionList = acoesSemanticas.getInstructionKList();
        errosSemanticos.append("Semantico OK!\n");

        language20221 = null;
        return errosSemanticos.toString();
    }

    public String errorListToString(String message, List<String> errors) {
        StringBuilder sb = new StringBuilder(message);
        System.out.println("tamanho da lista de erros:  " + errors.size());
        sb.append(String.format(" Count %s", errors.size())).append("\u005cn");
        for (String s : errors) {
            sb.append(s).append("\u005cn");
        }
        return sb.toString();
    }

    private Language20221 readInput(String args[], String textToAnalyze) {
        Language20221 sintatico = null;
        if(args.length == 0){
            System.out.println("Reading from received text!");
            java.io.InputStream targetStream = new java.io.ByteArrayInputStream(textToAnalyze.getBytes());
            sintatico = new Language20221(targetStream);
        }
        else if(args.length == 1){
            try{
                sintatico = new Language20221(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e){
                System.err.println(args[0] + " was not found." );
                System.err.println(e);
            }
        }
        else{
            System.out.println("Use:\njava Sintatico < inputFile");
            System.out.println("or java Sintatico inputFile");
        }
        return sintatico;
    }

    public void consumeUntil(RecoverySet g, ParseException e, String met) throws  ParseException {
        Token tok;
        if (g == null){
            throw e;
        }
        tok = getToken(1); // Current token
        while (!eof){
            /* found a token in set */
            if (g.contains(tok.kind)) {
                break;
            }
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && !g.contains(EOF)){
                eof = true;
            }
        }
        contSyntaticsErrors++;
    }

    public int getContLexicalErrors(){
        return contLexicalErrors;
    }

    public String getLexicalErrors(){
        return lexicalErrors.toString();
    }

    public int getContSyntaticsErrors() {
        return this.contSyntaticsErrors;
    }

    public String getSyntacticErrors() {
        return this.syntaticsErrors.toString();
    }

    public boolean hasAnyErrors() {
        return lexicalErrors.size()!=0
        || syntaticsErrors.size()!=0
        || semanticErrors.size()!= 0;
    }

}



PARSER_END(Language20221)

SKIP: {     //caracteres que o javacc excluirá da linguagem para nao interpretar
    " "
    | "\n"
    | "\t"
    | < "//" (~["\n", "\r"])* >
    | < "/*"> {TokenHandler.writeInvalidToOutput(image.toString(), input_stream.getEndLine(), input_stream.getBeginColumn(), jjmatchedKind);}: BLOCK_COMMENT_STATE
}

<BLOCK_COMMENT_STATE> SKIP: {
    <"*/"> {TokenHandler.setClosed(true);}: DEFAULT
    | <~[]>
}


//palavras reservadas
TOKEN [IGNORE_CASE]:
{
        < PALAVRA_RESERVADA_ALL: "all">
    |   < PALAVRA_RESERVADA_AND: "and">
    |   < PALAVRA_RESERVADA_AS:  "as">
    |   < PALAVRA_RESERVADA_AVALIATE: "avaliate">
    |   < PALAVRA_RESERVADA_BODY: "body">
    |   < PALAVRA_RESERVADA_CONSTANT: "constant">
    |   < PALAVRA_RESERVADA_DECLARATION: "declaration">
    |   < PALAVRA_RESERVADA_DESCRIPTION: "description">
    |   < PALAVRA_RESERVADA_DESIGNATE: "designate">
    |   < PALAVRA_RESERVADA_DO: "do">
    |   < PALAVRA_RESERVADA_INTEGER: "integer">
    |   < PALAVRA_RESERVADA_IS: "is">
    |   < PALAVRA_RESERVADA_LOGIC: "logic">
    |   < PALAVRA_RESERVADA_READ: "read">
    |   < PALAVRA_RESERVADA_REAL: "real">
    |   < PALAVRA_RESERVADA_REPEAT: "repeat">
    |   < PALAVRA_RESERVADA_RESULT: "result">
    |   < PALAVRA_RESERVADA_STRING: "string">
    |   < PALAVRA_RESERVADA_THIS: "this">
    |   < PALAVRA_RESERVADA_TRUE: "true">
    |   < PALAVRA_RESERVADA_TYPE: "type">
    |   < PALAVRA_RESERVADA_UNTRUE: "untrue">
    |   < PALAVRA_RESERVADA_VARIABLE: "variable">
    |   < PALAVRA_RESERVADA_WRITE: "write">
}

//Tokens Auxiliares
TOKEN : {
        < #LETRA_MINUSCULA: ["a"-"z"] >
    |   < #LETRA_MAIUSCULA: ["A"-"Z"]>
    |   < #LETRA: <LETRA_MAIUSCULA>| <LETRA_MINUSCULA> >
    |   < #ASCII : ~[] >      //any character
    |   < #DIGITO: ["0"-"9"] >
    |   < #UNDERLINE: "_" >

}

//Identificadores
TOKEN : {
     <IDENTIFICADOR: <LETRA_MAIUSCULA> ((<LETRA>)* (<IDENT1>)?
                         | (("_")? (<LETRA>)+ (<IDENT2>)) | ( <DIGITO> (<DIGITO>)? (<IDENT1> | <IDENT2>))) >
|    <#IDENT1: <DIGITO> (<DIGITO>)? ((<LETRA>)* "_" (<LETRA>)* <DIGITO> | (<LETRA>)+ <DIGITO> )*
                                     ((<LETRA>)+ (<DIGITO> (<DIGITO>)?)? ("_")? | (<LETRA>)+ (<DIGITO> (<DIGITO>)?)?)+ >
|    <#IDENT2: "_" ((<LETRA>)* <DIGITO> (<DIGITO>)? (<LETRA>)* "_" | (<DIGITO> (<DIGITO>)?)? (<LETRA>)+ ("_")?)* >

}


//Constantes Literais
TOKEN : {

    < CONSTANTE_LITERAL : ("\"" (~["\"","\n","\r"])* "\"") | ("'" (~["'","\n","\r"])* "'") >
    // ~["\""] => Qualquer caractere menos a aspa
    // ~["'"] => Qualquer caractere menos o apóstrofro
}

//Constantes Númericas (Real e Inteira)
TOKEN : {
        < CONSTANTE_NUMERICA_INTEIRA: <DIGITO> (<DIGITO>)? (<DIGITO>)? >                  // 1 a 3 digitos
    |   < #CONSTANTE_NUMERICA_REAL_CASAS_DECIMAIS: <DIGITO> (<DIGITO>)? (<DIGITO>)? >      // 1 A 3 digitos
    |   < CONSTANTE_NUMERICA_REAL:   <CONSTANTE_NUMERICA_INTEIRA> (<DIGITO>)? (<DIGITO>)? "." <CONSTANTE_NUMERICA_REAL_CASAS_DECIMAIS> >
}


//Símbolos Especiais
TOKEN :
{
        < SIMBOLO_ESPECIAL_ABRE_CHAVES: "{" >
    |   < SIMBOLO_ESPECIAL_FECHA_CHAVES: "}" >
    |   < SIMBOLO_ESPECIAL_PONTO_FINAL: "." >
    |   < SIMBOLO_ESPECIAL_VIRGULA: "," >
    |   < SIMBOLO_ESPECIAL_ABRE_COLCHETES: "[" >
    |   < SIMBOLO_ESPECIAL_FECHA_COLCHETES: "]" >
    |   < SIMBOLO_ESPECIAL_ABRE_PARENTESES: "(" >
    |   < SIMBOLO_ESPECIAL_FECHA_PARENTESES: ")" >
}

//Operadores Aritméticos
TOKEN :
{
        < OPERADOR_ARITMETICO_ADICAO: "+">
    |   < OPERADOR_ARITMETICO_SUBTRACAO: "-">
    |   < OPERADOR_ARITMETICO_MULTIPLICACAO: "*">
    |   < OPERADOR_ARITMETICO_DIVISAO: "/">
    |   < OPERADOR_ARITMETICO_POTENCIACAO: "**">
    |   < OPERADOR_ARITMETICO_DIVISAO_INTEIRA: "%">
    |   < OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA: "%%">
}

//Operadores Relacionais
TOKEN :
{
        < OPERADOR_RELACIONAL_IGUAL: "==">
    |   < OPERADOR_RELACIONAL_DIFERENTE: "!=">
    |   < OPERADOR_RELACIONAL_MENOR: "<<">
    |   < OPERADOR_RELACIONAL_MAIOR: ">>">
    |   < OPERADOR_RELACIONAL_MENOR_IGUAL: "<<=">
    |   < OPERADOR_RELACIONAL_MAIOR_IGUAL: ">>=">
}

//Operadores Lógicos
TOKEN :
{
        < OPERADOR_LOGICO_E: "&">
    |   < OPERADOR_LOGICO_OU: "|">
    |   < OPERADOR_LOGICO_NAO: "!">
}

//Operador Atribuição
TOKEN :
{
    < OPERADOR_ATRIBUICAO: "=">
}

//SÍMBOLOS INVÁLIDOS
TOKEN : {       //Caracteres que não são reconhecidos pela linguagem
        < SIMBOLO_INVALIDO :
            (~[             //Caracteres que não casam com esses descritos abaixam são considerados inválidos
                "A"-"Z",
                "a"-"z",
                "0"-"9",
                "\"",       //aspas
                "\'",       //apóstrofo
                "{",
                "}",
                ".",
                ",",
                "[",
                "]",
                "(",
                ")",
                "+",
                "-",
                "*",
                "/",
                "%",
                "=",
                "<",
                ">",
                "&",
                "|",
                "!",
                " ",
                "\t",
                "\n",
                "\r",
                "\f"
            ])+
        >
        |   < CONSTANTE_LITERAL_INVALIDA:    "\"" (~ ["\n", "\r", "\""])* | "\'" (~ ["\n", "\r", "\'"])* >
        |   < CONSTANTE_NUMERICA_INTEIRA_INVALIDA : <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ >
        |   < CONSTANTE_NUMERICA_REAL_INVALIDA :
                    (<DIGITO> <DIGITO> <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ "." <CONSTANTE_NUMERICA_REAL_CASAS_DECIMAIS>)                 // 6 casas inteiras ou +
               |    (<DIGITO> <DIGITO> <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ "." <CONSTANTE_NUMERICA_REAL_CASAS_DECIMAIS> (<DIGITO>)+)     // 6 casas inteiras ou + e com 4 casas decimais ou +
               |    (<DIGITO> (<DIGITO>)? (<DIGITO>)? (<DIGITO>)? (<DIGITO>)? "." <CONSTANTE_NUMERICA_REAL_CASAS_DECIMAIS> (<DIGITO>)+)     // Até 5 casas inteiras e com + de 3 casas decimais
            >
        |   < COMENTARIO_FACULTATIVO_INVALIDO : <PALAVRA_RESERVADA_DESCRIPTION> <CONSTANTE_LITERAL_INVALIDA> >
        //|   < IDENTIFICADOR_INVALIDO : ( <LETRA_MINUSCULA> | <UNDERLINE> ) (~ ["\n", "\r", " ", "\t"])* (<LETRA>)* >
        |       < IDENTIFICADOR_INVALIDO : <LETRA>(<LETRA>|<DIGITO>|(""))*<DIGITO>(<DIGITO>)+(<LETRA>|(""))* |
                <LETRA>(<LETRA>|<DIGITO>|("_"))*(<DIGITO>)+ |
                <LETRA>(<LETRA>|<DIGITO>)((""))+<DIGITO>(<LETRA>|<DIGITO>|("")) |
                (<DIGITO>)+(<LETRA>|<DIGITO>|("_"))* |
                ("")(<LETRA>|<DIGITO>|(""))*>
}

void enum_values(): {} {
    constant_result() | <IDENTIFICADOR>
}

void inner_enum_declaration(RecoverySet r) : {} {
    try {
        <IDENTIFICADOR> <PALAVRA_RESERVADA_IS> enum_values() inner_enum_decla_cont() <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }
    catch (ParseException e){
           consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
           syntaticsErrors.add(new ErrorStruct("Erro: declaracao de enum interna incorreta.\n", e));
        }
}

void inner_enum_decla_cont() : {} {
    (<SIMBOLO_ESPECIAL_VIRGULA> enum_values() inner_enum_decla_cont())?
}
void enum_declaration(RecoverySet r) : {} {
    try {
        <PALAVRA_RESERVADA_TYPE> <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
            (inner_enum_declaration(r))+
        <SIMBOLO_ESPECIAL_FECHA_COLCHETES>
        (<PALAVRA_RESERVADA_DECLARATION> declaration_constants_and_variables(r))?
    }
    catch (ParseException e){
       consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
       syntaticsErrors.add(new ErrorStruct("Erro: declaracao de enum incorreta.\n", e));
    }
}

void identifiers() : {} {
    <IDENTIFICADOR> index()


}

void identifiers_list() : {} {
    try {
        identifiers() (<SIMBOLO_ESPECIAL_VIRGULA> identifiers())*
    }catch (ParseException e){
        syntaticsErrors.add(new ErrorStruct("Erro: Lista de identificadores incorreto.\n", e));
    }
}

void type_declaration() : {} {
    <PALAVRA_RESERVADA_INTEGER>  {acoesSemanticas.acao13();}
    | <PALAVRA_RESERVADA_REAL> {acoesSemanticas.acao14();}
    | <PALAVRA_RESERVADA_STRING>  {acoesSemanticas.acao15();}
    | <PALAVRA_RESERVADA_LOGIC> {acoesSemanticas.acao16();}
    | <IDENTIFICADOR> {acoesSemanticas.acao17();}

}

void variable_declaration() : {} {
    identifiers_list() <PALAVRA_RESERVADA_IS> type_declaration() {acoesSemanticas.acao6();} <SIMBOLO_ESPECIAL_PONTO_FINAL>
}

void type_constant() : {} {
    <PALAVRA_RESERVADA_INTEGER> {acoesSemanticas.acao13();}
    |<PALAVRA_RESERVADA_REAL>   {acoesSemanticas.acao14();}
    | <PALAVRA_RESERVADA_STRING>    {acoesSemanticas.acao15();}
    | <PALAVRA_RESERVADA_LOGIC>     {acoesSemanticas.acao16(getToken(0));}
    | <IDENTIFICADOR>
}

void end_constant() : {} {
    <PALAVRA_RESERVADA_AS> <PALAVRA_RESERVADA_CONSTANT> {acoesSemanticas.acao5()} (constant_declaration())+
}

void start_variable() : {} {
    <PALAVRA_RESERVADA_VARIABLE> (variable_declaration())+ (end_constant())?
}

void constant_declaration() : {} {
    identifiers_list() <PALAVRA_RESERVADA_IS> type_constant() <OPERADOR_ATRIBUICAO> constant_result() <SIMBOLO_ESPECIAL_PONTO_FINAL>
}

void end_variable() : {} {
    <PALAVRA_RESERVADA_AS> <PALAVRA_RESERVADA_VARIABLE> {acoesSemanticas.acao8()} (variable_declaration())+
}

void start_constant() : {} {
    <PALAVRA_RESERVADA_CONSTANT> (constant_declaration())+ (end_variable())?
}

void start_declaration(RecoverySet r) : {} {
    try{
        start_variable() | start_constant()
    }catch (ParseException e){
         consumeUntil(r, e, "Error: Invalid declaration body.\n");
         syntaticsErrors.add(new ErrorStruct("Erro: Declaracao de variavel/constante errado.\n", e));
     }
}

void inner_declaration(RecoverySet r) : {} {
    try {
        <PALAVRA_RESERVADA_AS> start_declaration(r)
    }catch (ParseException e){
        consumeUntil(r, e, "Error: Invalid declaration body.\n");
        syntaticsErrors.add(new ErrorStruct("Error: Bad inner declaration of as.\n", e));
    }
}

void declaration_constants_and_variables(RecoverySet r) : {} {
    try{
       <PALAVRA_RESERVADA_CONSTANT> <PALAVRA_RESERVADA_AND> <PALAVRA_RESERVADA_VARIABLE> <SIMBOLO_ESPECIAL_ABRE_COLCHETES> inner_declaration(r) <SIMBOLO_ESPECIAL_FECHA_COLCHETES>
    }
    catch (ParseException e){
        consumeUntil(r, e, "declaration_constants_and_variables");
        syntaticsErrors.add(new ErrorStruct("Error: Forma geral de declaracao de constante e variaval incorreta.\n", e));
    }
}

void constant_result() : {} {
        <CONSTANTE_LITERAL>
    |   <CONSTANTE_NUMERICA_INTEIRA>
    |   <CONSTANTE_NUMERICA_REAL>
}

void logic_result(RecoverySet r ) : {RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);} {
    try {
            <PALAVRA_RESERVADA_TRUE> <PALAVRA_RESERVADA_RESULT> <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
            list_of_commands(g) <SIMBOLO_ESPECIAL_FECHA_COLCHETES> true_result_cont()
        |   <PALAVRA_RESERVADA_UNTRUE> <PALAVRA_RESERVADA_RESULT> <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
            list_of_commands(g) <SIMBOLO_ESPECIAL_FECHA_COLCHETES> untrue_result_cont()
    }catch (ParseException e){
        consumeUntil(r, e, "");
        syntaticsErrors.add(new ErrorStruct("Erro: Verificacao de resultado logico incorreto.\n", e));
    }
}

void true_result_cont() : {RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);} {
    try {
        (
            <PALAVRA_RESERVADA_UNTRUE> <PALAVRA_RESERVADA_RESULT> <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
            list_of_commands(g) <SIMBOLO_ESPECIAL_FECHA_COLCHETES> <SIMBOLO_ESPECIAL_PONTO_FINAL>
        )
        |   <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
        consumeUntil(g, e, "list_of_commands");
        syntaticsErrors.add(new ErrorStruct("Erro: Clausula de teste incorreta.\n", e));
    }
}

void untrue_result_cont() : {RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);} {
    try {
        (
            <PALAVRA_RESERVADA_TRUE> <PALAVRA_RESERVADA_RESULT> <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
            list_of_commands(g) <SIMBOLO_ESPECIAL_FECHA_COLCHETES> <SIMBOLO_ESPECIAL_PONTO_FINAL>
        )
        |   <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
        consumeUntil(g, e, "");
        syntaticsErrors.add(new ErrorStruct("Erro: Clausula de teste incorreta.\n", e));
    }
}

void declarations(RecoverySet r) : {} {
    try {
        (
            <PALAVRA_RESERVADA_DECLARATION>
                (
                        enum_declaration(r)
                    |   declaration_constants_and_variables(r)
                )
        )?
    }catch (ParseException e) {
        consumeUntil(r, e, "declarations");
        syntaticsErrors.add(new ErrorStruct("Erro de declaracao de enum/variable\n", e));
    }
}

void list_of_commands(RecoverySet r) : {RecoverySet g = First.list_of_commands ;} {
    try {
        (
                repeat(g)
            |   avaliate(g)
            |   (<PALAVRA_RESERVADA_WRITE> (write(g) | write_all(g)))
            |   designate(g)
            |   read(g)
        )+
    }catch (ParseException e){
        consumeUntil(r, e, "list_of_commands");
        syntaticsErrors.add(new ErrorStruct("Erro: Declaracao de comando incorreta.\n", e));
    }
}

void expression(RecoverySet g) : {} {
    try {
        arithmetic_or_logic_expression(g) expression_cont(g)
   }catch (ParseException e){
       consumeUntil(g, e, "list_of_commands");
       syntaticsErrors.add(new ErrorStruct("Erro: Expressao incorreta.\n", e));
   }
}

void arithmetic_or_logic_expression(RecoverySet g) : {} {
    second_term(g) lesser_priority_operators(g)
}

void expression_cont(RecoverySet g) : {} {
    (
            (<OPERADOR_RELACIONAL_IGUAL> arithmetic_or_logic_expression(g))
        |   (<OPERADOR_RELACIONAL_DIFERENTE> arithmetic_or_logic_expression(g))
        |   (<OPERADOR_RELACIONAL_MENOR> arithmetic_or_logic_expression(g))
        |   (<OPERADOR_RELACIONAL_MAIOR> arithmetic_or_logic_expression(g))
        |   (<OPERADOR_RELACIONAL_MENOR_IGUAL> arithmetic_or_logic_expression(g))
        |   (<OPERADOR_RELACIONAL_MAIOR_IGUAL> arithmetic_or_logic_expression(g))
    )?
}

void first_term(RecoverySet g) : {} {
    element(g) top_priority_operators(g)
}

void second_term(RecoverySet g) : {} {
    first_term(g) medium_priority_operators(g)
}

void element(RecoverySet g) : {} {
        (<IDENTIFICADOR> {acoesSemanticas.acao24()} index() {acoesSemanticas.acao51()})
    |   <CONSTANTE_NUMERICA_INTEIRA> {acoesSemanticas.acao26()}
    |   <CONSTANTE_NUMERICA_REAL> {acoesSemanticas.acao27()}
    |   <CONSTANTE_LITERAL> {acoesSemanticas.acao28();}
    |   <PALAVRA_RESERVADA_TRUE> {acoesSemanticas.acao52();}
    |   <PALAVRA_RESERVADA_UNTRUE> {acoesSemanticas.acao53()}
    |   (<SIMBOLO_ESPECIAL_ABRE_PARENTESES> expression(g) <SIMBOLO_ESPECIAL_FECHA_PARENTESES>)
    |   (<OPERADOR_LOGICO_NAO> <SIMBOLO_ESPECIAL_ABRE_PARENTESES> expression(g) <SIMBOLO_ESPECIAL_FECHA_PARENTESES> {acoesSemanticas.acao54()})
}

void index() : {} {
    (<SIMBOLO_ESPECIAL_ABRE_CHAVES> <CONSTANTE_NUMERICA_INTEIRA> {acoesSemanticas.acao12(g)} <SIMBOLO_ESPECIAL_FECHA_CHAVES>)?
}

void top_priority_operators(RecoverySet g) : {} {
    (<OPERADOR_ARITMETICO_POTENCIACAO> element(g))*
}

void medium_priority_operators(RecoverySet g) : {} {
    (
            (<OPERADOR_ARITMETICO_MULTIPLICACAO> first_term(g))
        |   (<OPERADOR_ARITMETICO_DIVISAO> first_term(g))
        |   (<OPERADOR_ARITMETICO_DIVISAO_INTEIRA> first_term(g))
        |   (<OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA> first_term(g))
        |   (<OPERADOR_LOGICO_E> first_term(g))
    )*
}

void lesser_priority_operators(RecoverySet g) : {} {
    (
            (<OPERADOR_ARITMETICO_ADICAO> second_term(g))
        |   (<OPERADOR_ARITMETICO_SUBTRACAO> second_term(g))
        |   (<OPERADOR_LOGICO_OU> second_term(g))
    )*
}

void repeat(RecoverySet r) : {
        RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        RecoverySet h = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
}{
    try {
        <PALAVRA_RESERVADA_REPEAT> <PALAVRA_RESERVADA_THIS> {acoesSemanticas.acao33()} expression(g)
        {acoesSemanticas.acao34()} <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
            list_of_commands(h)
        <SIMBOLO_ESPECIAL_FECHA_COLCHETES> {acoesSemanticas.acao35(g)} <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
       consumeUntil(r, e, "");
       syntaticsErrors.add(new ErrorStruct("Erro: Declaracao do comando repeat incorreta. \n", e));
    }
}

void avaliate(RecoverySet r) : {RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_PONTO_FINAL);} {
    try {
        <PALAVRA_RESERVADA_AVALIATE> <PALAVRA_RESERVADA_THIS>
        expression(First.selection_command)
        logic_result(g)
    }catch (ParseException e){
           consumeUntil(r, e, "");
           syntaticsErrors.add(new ErrorStruct("Erro: Declaracao do comando avaliate incorreta. \n", e));
    }
}

void write(RecoverySet g) : {} {
    try {
        <PALAVRA_RESERVADA_THIS> {acoesSemanticas.acao22(g)} <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
        write_body() <SIMBOLO_ESPECIAL_FECHA_COLCHETES> <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
        consumeUntil(g, e, "list_of_commands");
        syntaticsErrors.add(new ErrorStruct("Erro: Comando write incorreto.\n", e));
    }
}

void write_all(RecoverySet g) : {} {
    try {
        <PALAVRA_RESERVADA_ALL> <PALAVRA_RESERVADA_THIS> {acoesSemanticas.acao21();} <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
        write_body() <SIMBOLO_ESPECIAL_FECHA_COLCHETES> <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
       consumeUntil(g, e, "");
       syntaticsErrors.add(new ErrorStruct("Erro: no comando write all.\n", e));
    }

}

void write_body() : {} {
    try {
         (
            constant_result()
                    (<SIMBOLO_ESPECIAL_VIRGULA> write_body_cont())*
                |   identifiers()  (<SIMBOLO_ESPECIAL_VIRGULA> write_body_cont())*
         )
    }catch (ParseException e){
       syntaticsErrors.add(new ErrorStruct("Erro: Erro no corpo do write.\n", e));
    }
}

void write_body_cont() : {} {
    try {
        constant_result() | identifiers()
    }catch (ParseException e){
        syntaticsErrors.add(new ErrorStruct("Erro: Erro no corpo do write.\n", e));
    }
}

void designate(RecoverySet r) : {RecoverySet h = new RecoverySet(SIMBOLO_ESPECIAL_PONTO_FINAL);} {
    try {
        <PALAVRA_RESERVADA_DESIGNATE> <PALAVRA_RESERVADA_THIS> {acoesSemanticas.acao18();} identifiers_list()
        <PALAVRA_RESERVADA_AS> expression(h) {acoesSemanticas.acao19();} <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
       consumeUntil(r, e, "");
       syntaticsErrors.add(new ErrorStruct("Erro: Erro de atribuicao (designate).\n", e));
    }
}

void read(RecoverySet r) : {} {
    try {
        <PALAVRA_RESERVADA_READ> <PALAVRA_RESERVADA_THIS> {acoesSemanticas.acao20();} <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
        identifiers_list() <SIMBOLO_ESPECIAL_FECHA_COLCHETES> <SIMBOLO_ESPECIAL_PONTO_FINAL>
    }catch (ParseException e){
        consumeUntil(r, e, "read");
    }
}

void header(RecoverySet r) : {} {
    try {
        <PALAVRA_RESERVADA_DO> <PALAVRA_RESERVADA_THIS> <IDENTIFICADOR> {acoesSemanticas.acao1(getToken(0))} <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
        <SIMBOLO_ESPECIAL_FECHA_COLCHETES>
    }catch (ParseException e){
        consumeUntil(r, e, "header");
        syntaticsErrors.add(new ErrorStruct("Erro: Cabecalho principal incorreto.\n", e));
    }
}

void body(RecoverySet r) : {RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_ABRE_COLCHETES);} {
    try {
        <PALAVRA_RESERVADA_BODY>  <SIMBOLO_ESPECIAL_ABRE_COLCHETES>
        list_of_commands(g)
        <SIMBOLO_ESPECIAL_FECHA_COLCHETES>
    }catch (ParseException e){
        consumeUntil(r, e, "body");
        syntaticsErrors.add(new ErrorStruct("Erro: Declaracao do corpo incorreto.\n", e));
    }

}

void desc(RecoverySet r) : {} {
    try {
        (<PALAVRA_RESERVADA_DESCRIPTION> <CONSTANTE_LITERAL>)?
    }catch (ParseException e){
        consumeUntil(r, e, "description");
        syntaticsErrors.add(new ErrorStruct("Erro: Descricao do programa incorreto\n", e));
    }
}

void main(RecoverySet r) : {
        RecoverySet h = new RecoverySet(PALAVRA_RESERVADA_BODY);
        RecoverySet g = new RecoverySet(PALAVRA_RESERVADA_DECLARATION);
        RecoverySet i = g.union(h);
        RecoverySet l = new RecoverySet(PALAVRA_RESERVADA_DESCRIPTION);
        } {
    try {
            header(i)
            declarations(h)
            body(r.union(l))
            desc(r)
            {acoesSemanticas.acao2()}
    }catch (ParseException e){
        consumeUntil(r, e, "main");
    }
}

void begin_program() : {RecoverySet r = new RecoverySet(EOF);} {
    try {
        [ main(r) ] <EOF>
    }catch (ParseException e){
        consumeUntil(r, e, "begin_program");
        syntaticsErrors.add(new ErrorStruct("Erro: Forma geral do programa incorreto.\n", e));
    }

}
