/* Generated By:JavaCC: Do not edit this line. LanguageParser.java */
package classes;

//import javax.swing.text.html.parser.Parser;
import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.lang.StringBuilder;
import java.lang.StringBuilder;
import maquinavirtual.Instruction;
import maquinavirtual.VirtualMachine;
import maquinavirtual.SymbolTable;

public class LanguageParser implements LanguageParserConstants {
    int contParseError = 0;
    boolean debugRecovery = true;
    final static List<ErrorStruct> output = new ArrayList<ErrorStruct>();
    boolean eof;

    static List<String> listaComandos = new ArrayList<String>();
    static List<String> listaParametros = new ArrayList<String>();
    static LanguageRules regraDasLinguagem = new LanguageRules();
    static VirtualMachine maquina;
    static Instruction instrucoes;

    public static List<Token> getTokens(String stream){
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        LanguageParser parser = new LanguageParser(target);
        return tokenize(parser);
    }

    public LanguageParser LanguageParser(String code){
        this.checkSyntax(code);
        return this;
    }

    final public void adicionar_regra(String regra, List<String> lista_parametros_dentro_funcao) throws ParseException {
        System.out.println("Iniciando an\u00c3\u00a1lise sem\u00c3\u00a2ntica...");
        switch(regra){
            case "#2":
                regraDasLinguagem.regra2(lista_parametros_dentro_funcao.get(0));
                for(Instruction instrucao: regraDasLinguagem.getPilha_de_instrucoes()){
                    System.out.println(instrucao.getPonteiro() + " | "
                        + instrucao.getInstrucao()
                        + " | " + instrucao.getEndereco());
                }
                System.out.println("\n\n");
                for(SymbolTable tabelaSimbolo: regraDasLinguagem.getPilha_de_simbolos()){
                    System.out.println(tabelaSimbolo.getIdentificador()
                        + " | " + tabelaSimbolo.getCategoria()
                        + " | " + tabelaSimbolo.getAtributo1()
                        + " | " + tabelaSimbolo.getAtributo2());
                }
                break;
                case "#2":
                    regraDasLinguagem.regra2();
                    break;
                case "#6":
                    regraDasLinguagem.regra6();
                    break;
                case "#7":
                    regraDasLinguagem.regra7(lista_parametros_dentro_funcao.get(0));
                    break;
                case "#5":
                    regraDasLinguagem.regra8();
                    break;
                case "#13":
                    regraDasLinguagem.regra13();
                    break;
                case "#14":
                    regraDasLinguagem.regra14();
                    break;
                case "#15":
                    regraDasLinguagem.regra15();
                    break;
                case "#16":
                    regraDasLinguagem.regra16();
                    break;
                case "#9":
                    regraDasLinguagem.regra9(lista_parametros_dentro_funcao.get(0));
                    break;
                case "#10":
                    regraDasLinguagem.regra10(lista_parametros_dentro_funcao.get(0));
                    break;
                case "#11":
                    regraDasLinguagem.regra11();
                    break;
                case "#12":
                    regraDasLinguagem.regra12(Integer.parseInt(lista_parametros_dentro_funcao.get(0)));
                    break;
                case "#18":
                    regraDasLinguagem.regra18();
                    break;
                case "#15":
                    regraDasLinguagem.regra15();
                    break;
                case "#20":
                    regraDasLinguagem.regra20();
                    break;
                case "#23":
                    regraDasLinguagem.regra23();
                    break;
                case "#24":
                    regraDasLinguagem.regra24(lista_parametros_dentro_funcao.get(0));
                    break;
                case "#25":
                    regraDasLinguagem.regra25();
                    break;
                case "#26":
                    regraDasLinguagem.regra26(Integer.parseInt(lista_parametros_dentro_funcao.get(0)));
                    break;
                case "#27":
                    regraDasLinguagem.regra27(Float.parseFloat(lista_parametros_dentro_funcao.get(0)));
                    break;
                case "#28":
                    regraDasLinguagem.regra28(lista_parametros_dentro_funcao.get(0));
                    break;
                case "#23":
                    regraDasLinguagem.regra23();
                    break;
                case "#30":
                    regraDasLinguagem.regra30();
                    break;
                case "#31":
                    regraDasLinguagem.regra31();
                    break;
                case "#32":
                    regraDasLinguagem.regra32();
                    break;
               case "#33":
                    regraDasLinguagem.regra33();
                    break;
               case "#28":
                    regraDasLinguagem.regra28();
                    break;
               case "#29":
                    regraDasLinguagem.regra29();
                    break;
               case "#30":
                    regraDasLinguagem.regra30();
                    break;
               case "#35":
                    regraDasLinguagem.regra35();
                    break;
               case "#36":
                    regraDasLinguagem.regra36();
                    break;
               case "#33":
                    regraDasLinguagem.regra33();
                    break;
               case "#34":
                    regraDasLinguagem.regra34();
                    break;
               case "#35":
                    regraDasLinguagem.regra35();
                    break;
               case "#36":
                    regraDasLinguagem.regra36();
                    break;
               case "#37":
                    regraDasLinguagem.regra37();
                    break;
               case "#42":
                    regraDasLinguagem.regra42();
                    break;
               case "#39":
                    regraDasLinguagem.regra39();
                    break;
               case "#44":
                    regraDasLinguagem.regra44();
                    break;
               case "#41":
                    regraDasLinguagem.regra41();
                    break;
               case "#42":
                    regraDasLinguagem.regra42();
                    break;
               case "#43":
                    regraDasLinguagem.regra43();
                    break;
               case "#44":
                    regraDasLinguagem.regra44();
                    break;
               case "#49":
                    regraDasLinguagem.regra49();
                    break;
               case "#46":
                    regraDasLinguagem.regra46();
                    break;
               case "#52":
                    regraDasLinguagem.regra52();
                    break;
               case "#53":
                    regraDasLinguagem.regra48();
                    break;
               case "#54":
                    regraDasLinguagem.regra49();
                    break;
               default :
                  break;
        }
    }

    public static ArrayList<ErrorStruct> checkSyntax(String stream) {
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        LanguageParser parser = new LanguageParser(target);
        try {
            parser.begin_program();
            }
        catch (ParseException e){
            output.add(new ErrorStruct("Error parsing the program.\n", e));
        }
        ArrayList tmp = new ArrayList<ErrorStruct>(output);
        output.clear();
        return tmp;
    }

   public static LanguageParser create(String stream){
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        LanguageParser parser = new LanguageParser(target);
        return parser;
   }

    public static void main(String args[]) throws TokenMgrError, ParseException {
        LanguageParser parser = null;
        if (args.length == 0) {
            parser = new LanguageParser(System.in);
        }
        else if (args.length == 1) {
            try {
                parser = new LanguageParser(new java.io.FileInputStream(args[0]));
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("LanguageParser: file " + args[0] + " was not found.");
                return;
            }
        }

        //for (Token token: tokenize(parser)){
        //    String name = LanguageParserConstants.tokenImage[token.kind];
        //    System.out.println("Line " + token.beginLine + " | Column " + token.beginColumn + " | " + token + "\n");
        //}
    }

    public static List<Token> tokenize(LanguageParser parser){
        List<Token> tokens = new ArrayList<Token>();

        Token token = parser.getNextToken();
        while (token.kind != LanguageParserConstants.EOF){
            tokens.add(token);
            token = parser.getNextToken();
        }

        if (!TokenHandler.isClosed()){
            tokens.add(TokenHandler.createToken());
        }

        return tokens;
    }

    static public String im(int x){
        String s = tokenImage[x];
        int k = s.lastIndexOf("\"");
        try {
            s = s.substring(1, k);
        }
        catch (StringIndexOutOfBoundsException e){}
        return s;
    }

    public void consumeUntil(RecoverySet g, ParseException e, String met) throws  ParseException {
        Token tok;
        if (g == null){
            throw e;
        }
        tok = getToken(1); // Current token
        while (!eof){
            /* found a token in set */
            if (g.contains(tok.kind)) {
                break;
            }
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && !g.contains(EOF)){
                eof = true;
            }
        }
        contParseError++;
    }

  final public void enum_values() throws ParseException {
    trace_call("enum_values");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case NUMBER_REAL:
      case STRING_LITERAL:
        constant_result();
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("enum_values");
    }
  }

  final public void inner_enum_declaration(RecoverySet r) throws ParseException {
    trace_call("inner_enum_declaration");
    try {
      try {
        jj_consume_token(IDENTIFIER);
        adicionar_regra("#3");
        jj_consume_token(IS);
        enum_values();
        inner_enum_decla_cont();
        jj_consume_token(DOT);
      } catch (ParseException e) {
           consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
           output.add(new ErrorStruct("Erro: declaracao de enum interna incorreta.\n", e));
      }
    } finally {
      trace_return("inner_enum_declaration");
    }
  }

  final public void inner_enum_decla_cont() throws ParseException {
    trace_call("inner_enum_decla_cont");
    try {
      adicionar_regra("#4");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        enum_values();
        inner_enum_decla_cont();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
    } finally {
      trace_return("inner_enum_decla_cont");
    }
  }

  final public void enum_declaration(RecoverySet r) throws ParseException {
    trace_call("enum_declaration");
    try {
      try {
        jj_consume_token(TYPE);
        jj_consume_token(OPEN_BRACKET);
        label_1:
        while (true) {
          inner_enum_declaration(r);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_1;
          }
        }
        jj_consume_token(CLOSE_BRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DECLARATION:
          jj_consume_token(DECLARATION);
          declaration_constants_and_variables(r);
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
      } catch (ParseException e) {
       consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
       output.add(new ErrorStruct("Erro: declaracao de enum incorreta.\n", e));
      }
    } finally {
      trace_return("enum_declaration");
    }
  }

  final public void identifiers() throws ParseException {
    trace_call("identifiers");
    try {
      jj_consume_token(IDENTIFIER);
      adicionar_regra("#24");
      index();
      adicionar_regra("#25");
    } finally {
      trace_return("identifiers");
    }
  }

  final public void identifiers_list() throws ParseException {
    trace_call("identifiers_list");
    try {
      try {
        identifiers();
        adicionar_regra("#23");
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_2;
          }
          jj_consume_token(COMMA);
          identifiers();
        }
      } catch (ParseException e) {
              output.add(new ErrorStruct("Erro: Lista de identificadores incorreto.\n", e));
      }
    } finally {
      trace_return("identifiers_list");
    }
  }

  final public void type_declaration() throws ParseException {
    trace_call("type_declaration");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        jj_consume_token(INTEGER);
        adicionar_regra("#13");
        break;
      case REAL:
        jj_consume_token(REAL);
        adicionar_regra("#14");
        break;
      case STRING:
        jj_consume_token(STRING);
        adicionar_regra("#15");
        break;
      case LOGIC:
        jj_consume_token(LOGIC);
        adicionar_regra("#16");
        break;
      case ENUM:
        jj_consume_token(ENUM);
        adicionar_regra("#17");
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("type_declaration");
    }
  }

  final public void variable_declaration() throws ParseException {
    trace_call("variable_declaration");
    try {
      adicionar_regra("#8");
      identifiers_list();
      jj_consume_token(IS);
      type_declaration();
      jj_consume_token(DOT);
    } finally {
      trace_return("variable_declaration");
    }
  }

  final public void type_constant() throws ParseException {
    trace_call("type_constant");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case REAL:
        jj_consume_token(REAL);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case LOGIC:
        jj_consume_token(LOGIC);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("type_constant");
    }
  }

  final public void end_constant() throws ParseException {
    trace_call("end_constant");
    try {
      jj_consume_token(AS);
      jj_consume_token(CONSTANT);
      label_3:
      while (true) {
        constant_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
      }
    } finally {
      trace_return("end_constant");
    }
  }

  final public void start_variable() throws ParseException {
    trace_call("start_variable");
    try {
      jj_consume_token(VARIABLE);
      label_4:
      while (true) {
        variable_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_4;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        end_constant();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
    } finally {
      trace_return("start_variable");
    }
  }

  final public void constant_declaration() throws ParseException {
    trace_call("constant_declaration");
    try {
      adicionar_regra("#5");
      identifiers_list();
      jj_consume_token(IS);
      type_constant();
      adicionar_regra("#6");
      jj_consume_token(ASSIGN);
      constant_result();
      adicionar_regra("#7");
      jj_consume_token(DOT);
    } finally {
      trace_return("constant_declaration");
    }
  }

  final public void end_variable() throws ParseException {
    trace_call("end_variable");
    try {
      jj_consume_token(AS);
      jj_consume_token(VARIABLE);
      label_5:
      while (true) {
        variable_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
      }
    } finally {
      trace_return("end_variable");
    }
  }

  final public void start_constant() throws ParseException {
    trace_call("start_constant");
    try {
      jj_consume_token(CONSTANT);
      label_6:
      while (true) {
        constant_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        end_variable();
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
    } finally {
      trace_return("start_constant");
    }
  }

  final public void start_declaration(RecoverySet r) throws ParseException {
    trace_call("start_declaration");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARIABLE:
          start_variable();
          break;
        case CONSTANT:
          start_constant();
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
         consumeUntil(r, e, "Error: Invalid declaration body.\n");
         output.add(new ErrorStruct("Erro: Declaracao de variavel/constante errado.\n", e));
      }
    } finally {
      trace_return("start_declaration");
    }
  }

  final public void inner_declaration(RecoverySet r) throws ParseException {
    trace_call("inner_declaration");
    try {
      try {
        jj_consume_token(AS);
        adicionar_regra("#5");
        start_declaration(r);
      } catch (ParseException e) {
        consumeUntil(r, e, "Error: Invalid declaration body.\n");
        output.add(new ErrorStruct("Error: Bad inner declaration of as.\n", e));
      }
    } finally {
      trace_return("inner_declaration");
    }
  }

  final public void declaration_constants_and_variables(RecoverySet r) throws ParseException {
    trace_call("declaration_constants_and_variables");
    try {
      try {
        jj_consume_token(CONSTANT);
        jj_consume_token(AND);
        jj_consume_token(VARIABLE);
        jj_consume_token(OPEN_BRACKET);
        inner_declaration(r);
        jj_consume_token(CLOSE_BRACKET);
      } catch (ParseException e) {
        consumeUntil(r, e, "declaration_constants_and_variables");
        output.add(new ErrorStruct("Error: Forma geral de declaracao de constante e variaval incorreta.\n", e));
      }
    } finally {
      trace_return("declaration_constants_and_variables");
    }
  }

  final public void constant_result() throws ParseException {
    trace_call("constant_result");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        break;
      case NUM:
        jj_consume_token(NUM);
        break;
      case NUMBER_REAL:
        jj_consume_token(NUMBER_REAL);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("constant_result");
    }
  }

  final public void logic_result(RecoverySet r) throws ParseException {
    trace_call("logic_result");
    try {
                                     RecoverySet g = new RecoverySet(CLOSE_BRACKET);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
          jj_consume_token(TRUE);
          jj_consume_token(RESULT);
          adicionar_regra("#32");
          jj_consume_token(OPEN_BRACKET);
          list_of_commands(g);
          jj_consume_token(CLOSE_BRACKET);
          true_result_cont();
          break;
        case UNTRUE:
          jj_consume_token(UNTRUE);
          jj_consume_token(RESULT);
          adicionar_regra("#32");
          jj_consume_token(OPEN_BRACKET);
          list_of_commands(g);
          jj_consume_token(CLOSE_BRACKET);
          untrue_result_cont();
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
           consumeUntil(r, e, "");
           output.add(new ErrorStruct("Erro: Verificacao de resultado logico incorreto.\n", e));
      }
    } finally {
      trace_return("logic_result");
    }
  }

  final public void true_result_cont() throws ParseException {
    trace_call("true_result_cont");
    try {
                           RecoverySet g = new RecoverySet(CLOSE_BRACKET);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNTRUE:
          jj_consume_token(UNTRUE);
          jj_consume_token(RESULT);
          adicionar_regra("#31");
          jj_consume_token(OPEN_BRACKET);
          list_of_commands(g);
          jj_consume_token(CLOSE_BRACKET);
          jj_consume_token(DOT);
          break;
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
           consumeUntil(g, e, "list_of_commands");
           output.add(new ErrorStruct("Erro: Clausula de teste incorreta.\n", e));
      }
    } finally {
      trace_return("true_result_cont");
    }
  }

  final public void untrue_result_cont() throws ParseException {
    trace_call("untrue_result_cont");
    try {
                             RecoverySet g = new RecoverySet(CLOSE_BRACKET);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
          jj_consume_token(TRUE);
          jj_consume_token(RESULT);
          adicionar_regra("#30");
          jj_consume_token(OPEN_BRACKET);
          list_of_commands(g);
          jj_consume_token(CLOSE_BRACKET);
          jj_consume_token(DOT);
          break;
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        consumeUntil(g, e, "");
        output.add(new ErrorStruct("Erro: Clausula de teste incorreta.\n", e));
      }
    } finally {
      trace_return("untrue_result_cont");
    }
  }

  final public void declarations(RecoverySet r) throws ParseException {
    trace_call("declarations");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DECLARATION:
          jj_consume_token(DECLARATION);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TYPE:
            enum_declaration(r);
            break;
          case CONSTANT:
            declaration_constants_and_variables(r);
            break;
          default:
            jj_la1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
      } catch (ParseException e) {
       consumeUntil(r, e, "declarations");
       output.add(new ErrorStruct("Erro de declaracao de enum/variable\n", e));
      }
    } finally {
      trace_return("declarations");
    }
  }

  final public void list_of_commands(RecoverySet r) throws ParseException {
    trace_call("list_of_commands");
    try {
                                        RecoverySet g = First.list_of_commands ;
      try {
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case REPEAT:
            repeat(g);
            break;
          case AVALIATE:
            avaliate(g);
            break;
          case WRITE:
            jj_consume_token(WRITE);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case THIS:
              write(g);
              break;
            case ALL:
              write_all(g);
              break;
            default:
              jj_la1[20] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          case DESIGNATE:
            designate(g);
            break;
          case READ:
            read(g);
            break;
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DESIGNATE:
          case READ:
          case WRITE:
          case AVALIATE:
          case REPEAT:
            ;
            break;
          default:
            jj_la1[22] = jj_gen;
            break label_7;
          }
        }
      } catch (ParseException e) {
        consumeUntil(r, e, "list_of_commands");
        output.add(new ErrorStruct("Erro: Declaracao de comando incorreta.\n", e));
      }
    } finally {
      trace_return("list_of_commands");
    }
  }

  final public void expression(RecoverySet g) throws ParseException {
    trace_call("expression");
    try {
      try {
        arithmetic_or_logic_expression(g);
        expression_cont(g);
      } catch (ParseException e) {
       consumeUntil(g, e, "list_of_commands");
       output.add(new ErrorStruct("Erro: Expressao incorreta.\n", e));
      }
    } finally {
      trace_return("expression");
    }
  }

  final public void arithmetic_or_logic_expression(RecoverySet g) throws ParseException {
    trace_call("arithmetic_or_logic_expression");
    try {
      second_term(g);
      lesser_priority_operators(g);
    } finally {
      trace_return("arithmetic_or_logic_expression");
    }
  }

  final public void expression_cont(RecoverySet g) throws ParseException {
    trace_call("expression_cont");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL_TO:
      case DIFF_THAN:
      case LESS_THAN:
      case GREATER_THAN:
      case LESS_THAN_OR_EQ_TO:
      case GREATER_THAN_OR_EQ_TO:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUAL_TO:
          jj_consume_token(EQUAL_TO);
          arithmetic_or_logic_expression(g);
          adicionar_regra("#36");
          break;
        case DIFF_THAN:
          jj_consume_token(DIFF_THAN);
          arithmetic_or_logic_expression(g);
          adicionar_regra("#37");
          break;
        case LESS_THAN:
          jj_consume_token(LESS_THAN);
          arithmetic_or_logic_expression(g);
          adicionar_regra("#38");
          break;
        case GREATER_THAN:
          jj_consume_token(GREATER_THAN);
          arithmetic_or_logic_expression(g);
          adicionar_regra("#39");
          break;
        case LESS_THAN_OR_EQ_TO:
          jj_consume_token(LESS_THAN_OR_EQ_TO);
          arithmetic_or_logic_expression(g);
          adicionar_regra("#40");
          break;
        case GREATER_THAN_OR_EQ_TO:
          jj_consume_token(GREATER_THAN_OR_EQ_TO);
          arithmetic_or_logic_expression(g);
          adicionar_regra("#41");
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
    } finally {
      trace_return("expression_cont");
    }
  }

  final public void first_term(RecoverySet g) throws ParseException {
    trace_call("first_term");
    try {
      element(g);
      top_priority_operators(g);
    } finally {
      trace_return("first_term");
    }
  }

  final public void second_term(RecoverySet g) throws ParseException {
    trace_call("second_term");
    try {
      first_term(g);
      medium_priority_operators(g);
    } finally {
      trace_return("second_term");
    }
  }

  final public void element(RecoverySet g) throws ParseException {
    trace_call("element");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        index();
        break;
      case NUM:
        jj_consume_token(NUM);
        adicionar_regra("#26");
        break;
      case NUMBER_REAL:
        jj_consume_token(NUMBER_REAL);
        adicionar_regra("#27");
        break;
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        adicionar_regra("#28");
        break;
      case TRUE:
        jj_consume_token(TRUE);
        adicionar_regra("#52");
        break;
      case UNTRUE:
        jj_consume_token(UNTRUE);
        adicionar_regra("#53");
        break;
      case OPEN_PARENTHESIS:
        jj_consume_token(OPEN_PARENTHESIS);
        expression(g);
        jj_consume_token(CLOSE_PARENTHESIS);
        break;
      case LOGICAL_NOT:
        jj_consume_token(LOGICAL_NOT);
        jj_consume_token(OPEN_PARENTHESIS);
        expression(g);
        jj_consume_token(CLOSE_PARENTHESIS);
        adicionar_regra("#54");
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("element");
    }
  }

  final public void index() throws ParseException {
    trace_call("index");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_CURLY_BRACKETS:
        jj_consume_token(OPEN_CURLY_BRACKETS);
        jj_consume_token(NUM);
        adicionar_regra("#17");
        jj_consume_token(CLOSE_CURLY_BRACKETS);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } finally {
      trace_return("index");
    }
  }

  final public void top_priority_operators(RecoverySet g) throws ParseException {
    trace_call("top_priority_operators");
    try {
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POWER:
          ;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_8;
        }
        jj_consume_token(POWER);
        element(g);
        adicionar_regra("#50");
      }
    } finally {
      trace_return("top_priority_operators");
    }
  }

  final public void medium_priority_operators(RecoverySet g) throws ParseException {
    trace_call("medium_priority_operators");
    try {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
        case DIV:
        case WHOLE_DIV:
        case REST_DIV:
        case LOGICAL_AND:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
          jj_consume_token(MULTIPLY);
          first_term(g);
          adicionar_regra("#45");
          break;
        case DIV:
          jj_consume_token(DIV);
          first_term(g);
          adicionar_regra("#46");
          break;
        case WHOLE_DIV:
          jj_consume_token(WHOLE_DIV);
          first_term(g);
          adicionar_regra("#47");
          break;
        case REST_DIV:
          jj_consume_token(REST_DIV);
          first_term(g);
          adicionar_regra("#48");
          break;
        case LOGICAL_AND:
          jj_consume_token(LOGICAL_AND);
          first_term(g);
          adicionar_regra("#49");
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("medium_priority_operators");
    }
  }

  final public void lesser_priority_operators(RecoverySet g) throws ParseException {
    trace_call("lesser_priority_operators");
    try {
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
        case LOGICAL_OR:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_10;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          second_term(g);
          adicionar_regra("#42");
          break;
        case MINUS:
          jj_consume_token(MINUS);
          second_term(g);
          adicionar_regra("#43");
          break;
        case LOGICAL_OR:
          jj_consume_token(LOGICAL_OR);
          second_term(g);
          adicionar_regra("#44");
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("lesser_priority_operators");
    }
  }

  final public void repeat(RecoverySet r) throws ParseException {
    trace_call("repeat");
    try {
        RecoverySet g = new RecoverySet(OPEN_BRACKET);
        RecoverySet h = new RecoverySet(CLOSE_BRACKET);
      try {
        jj_consume_token(REPEAT);
        jj_consume_token(THIS);
        adicionar_regra("#33");
        expression(g);
        adicionar_regra("#34");
        jj_consume_token(OPEN_BRACKET);
        list_of_commands(h);
        jj_consume_token(CLOSE_BRACKET);
        adicionar_regra("#35");
        jj_consume_token(DOT);
      } catch (ParseException e) {
       consumeUntil(r, e, "");
       output.add(new ErrorStruct("Erro: Declaracao do comando repeat incorreta. \n", e));
      }
    } finally {
      trace_return("repeat");
    }
  }

  final public void avaliate(RecoverySet r) throws ParseException {
    trace_call("avaliate");
    try {
                                RecoverySet g = new RecoverySet(DOT);
      try {
        jj_consume_token(AVALIATE);
        jj_consume_token(THIS);
        expression(First.selection_command);
        logic_result(g);
      } catch (ParseException e) {
           consumeUntil(r, e, "");
           output.add(new ErrorStruct("Erro: Declaracao do comando avaliate incorreta. \n", e));
      }
    } finally {
      trace_return("avaliate");
    }
  }

  final public void write(RecoverySet g) throws ParseException {
    trace_call("write");
    try {
      try {
        jj_consume_token(THIS);
        jj_consume_token(OPEN_BRACKET);
        write_body();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DOT);
      } catch (ParseException e) {
        consumeUntil(g, e, "list_of_commands");
        output.add(new ErrorStruct("Erro: Comando write incorreto.\n", e));
      }
    } finally {
      trace_return("write");
    }
  }

  final public void write_all(RecoverySet g) throws ParseException {
    trace_call("write_all");
    try {
      try {
        jj_consume_token(ALL);
        jj_consume_token(THIS);
        jj_consume_token(OPEN_BRACKET);
        write_body();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DOT);
      } catch (ParseException e) {
       consumeUntil(g, e, "");
       output.add(new ErrorStruct("Erro: no comando write all.\n", e));
      }
    } finally {
      trace_return("write_all");
    }
  }

  final public void write_body() throws ParseException {
    trace_call("write_body");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case NUMBER_REAL:
        case STRING_LITERAL:
          constant_result();
          label_11:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[32] = jj_gen;
              break label_11;
            }
            jj_consume_token(COMMA);
            write_body_cont();
          }
          break;
        case IDENTIFIER:
          identifiers();
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[33] = jj_gen;
              break label_12;
            }
            jj_consume_token(COMMA);
            write_body_cont();
          }
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
       output.add(new ErrorStruct("Erro: Erro no corpo do write.\n", e));
      }
    } finally {
      trace_return("write_body");
    }
  }

  final public void write_body_cont() throws ParseException {
    trace_call("write_body_cont");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case NUMBER_REAL:
        case STRING_LITERAL:
          constant_result();
          break;
        case IDENTIFIER:
          identifiers();
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        output.add(new ErrorStruct("Erro: Erro no corpo do write.\n", e));
      }
    } finally {
      trace_return("write_body_cont");
    }
  }

  final public void designate(RecoverySet r) throws ParseException {
    trace_call("designate");
    try {
                                 RecoverySet h = new RecoverySet(DOT);
      try {
        jj_consume_token(DESIGNATE);
        jj_consume_token(THIS);
        adicionar_regra("#18");
        identifiers_list();
        jj_consume_token(AS);
        expression(h);
        adicionar_regra("#19");
        jj_consume_token(DOT);
      } catch (ParseException e) {
       consumeUntil(r, e, "");
       output.add(new ErrorStruct("Erro: Erro de atribuicao (designate).\n", e));
      }
    } finally {
      trace_return("designate");
    }
  }

  final public void read(RecoverySet r) throws ParseException {
    trace_call("read");
    try {
      try {
        jj_consume_token(READ);
        jj_consume_token(THIS);
        adicionar_regra("#20");
        jj_consume_token(OPEN_BRACKET);
        identifiers_list();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DOT);
      } catch (ParseException e) {
        consumeUntil(r, e, "read");
      }
    } finally {
      trace_return("read");
    }
  }

  final public void header(RecoverySet r) throws ParseException {
    trace_call("header");
    try {
      try {
        jj_consume_token(DO);
        jj_consume_token(THIS);
        jj_consume_token(IDENTIFIER);
        adicionar_regra("#1");
        jj_consume_token(OPEN_BRACKET);
        jj_consume_token(CLOSE_BRACKET);
      } catch (ParseException e) {
        consumeUntil(r, e, "header");
        output.add(new ErrorStruct("Erro: Cabecalho principal incorreto.\n", e));
      }
    } finally {
      trace_return("header");
    }
  }

  final public void body(RecoverySet r) throws ParseException {
    trace_call("body");
    try {
                            RecoverySet g = new RecoverySet(OPEN_BRACKET);
      try {
        jj_consume_token(BODY);
        jj_consume_token(OPEN_BRACKET);
        list_of_commands(g);
        jj_consume_token(CLOSE_BRACKET);
      } catch (ParseException e) {
        consumeUntil(r, e, "body");
        output.add(new ErrorStruct("Erro: Declaracao do corpo incorreto.\n", e));
      }
    } finally {
      trace_return("body");
    }
  }

  final public void desc(RecoverySet r) throws ParseException {
    trace_call("desc");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCRIPTION:
          jj_consume_token(DESCRIPTION);
          jj_consume_token(STRING_LITERAL);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        consumeUntil(r, e, "description");
        output.add(new ErrorStruct("Erro: Descricao do programa incorreto\n", e));
      }
    } finally {
      trace_return("desc");
    }
  }

  final public void main(RecoverySet r) throws ParseException {
    trace_call("main");
    try {
        RecoverySet h = new RecoverySet(BODY);
        RecoverySet g = new RecoverySet(DECLARATION);
        RecoverySet i = g.union(h);
        RecoverySet l = new RecoverySet(DESCRIPTION);
      try {
        header(i);
        declarations(h);
        body(r.union(l));
        desc(r);
        adicionar_regra("#2");
      } catch (ParseException e) {
        consumeUntil(r, e, "main");
      }
    } finally {
      trace_return("main");
    }
  }

  final public void adicionar_regra(String regra) throws ParseException {
    trace_call("adicionar_regra");
    try {
      try {
        adicionar_regra2(regra, null);
      } catch (ParseException e) {
        output.add(new ErrorStruct("", null));
      }
    } finally {
      trace_return("adicionar_regra");
    }
  }

  final public void adicionar_regra2(String regra, List<String> lista_parametros) throws ParseException {
    trace_call("adicionar_regra2");
    try {
      try {
        Empty();
      } catch (ParseException e) {
        output.add(new ErrorStruct("", null));
      }
    } finally {
      trace_return("adicionar_regra2");
    }
  }

  final public void Empty() throws ParseException {
    trace_call("Empty");
    try {

    } finally {
      trace_return("Empty");
    }
  }

  final public void begin_program() throws ParseException {
    trace_call("begin_program");
    try {
                        RecoverySet r = new RecoverySet(EOF);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DO:
          main(r);
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        jj_consume_token(0);
      } catch (ParseException e) {
        consumeUntil(r, e, "begin_program");
        output.add(new ErrorStruct("Erro: Forma geral do programa incorreto.\n", e));
      }
    } finally {
      trace_return("begin_program");
    }
  }

  /** Generated Token Manager. */
  public LanguageParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[38];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x20000000,0x0,0x80000700,0x700,0x0,0x0,0x40000,0x0,0x0,0x40000,0x300000,0x0,0x1800,0x1000,0x800,0x40100000,0x20000000,0x2004000,0x15c00000,0x15c00000,0x0,0x0,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x2000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x200000,0x0,0x0,0x200000,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x3e80,0x3e80,0x1010000,0x40000,0x10,0x40006c,0x40006c,0x800003,0x800003,0x200000,0x200000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xa9,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x1,0x1,0x0,0x0,0xa8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa9,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa9,0xa9,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public LanguageParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public LanguageParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new LanguageParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public LanguageParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new LanguageParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public LanguageParser(LanguageParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(LanguageParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[78];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 38; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 78; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
