/* Generated By:JavaCC: Do not edit this line. Language20221.java */
package classes;

//import org.javacc.parser.Token;
//import org.javacc.parser.ParseException;
//import javax.swing.text.html.parser.Parser;

import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.lang.StringBuilder;

public class Language20221 implements Language20221Constants {
    private StringBuilder tokens = new StringBuilder();
    private StringBuilder lexicalErrors = new StringBuilder();
    private Boolean hasLexicalErrors = false;
    private int contLexicalErrors = 0;
    static List<ErrorStruct> syntaticsErrors = new ArrayList<ErrorStruct>();
    //final static List<ErrorStruct> syntaticsErrorsReturnTela = null;
    boolean debugRecovery = true;
    boolean eof;
    private int contSyntaticsErrors = 0;


    public void leituraDeTokens()  {
        try {
            Token t = null;
            t = getNextToken();
            if (t.kind == EOF) return;
            //System.out.println("KIND DO TOKEN LIDO: " + t.kind);
            switch(t.kind){
                case PALAVRA_RESERVADA_ALL        :
                case PALAVRA_RESERVADA_AND        :
                case PALAVRA_RESERVADA_AS         :
                case PALAVRA_RESERVADA_AVALIATE   :
                case PALAVRA_RESERVADA_BODY       :
                case PALAVRA_RESERVADA_CONSTANT   :
                case PALAVRA_RESERVADA_DECLARATION:
                case PALAVRA_RESERVADA_DESCRIPTION:
                case PALAVRA_RESERVADA_DESIGNATE  :
                case PALAVRA_RESERVADA_DO         :
                case PALAVRA_RESERVADA_INTEGER    :
                case PALAVRA_RESERVADA_IS         :
                case PALAVRA_RESERVADA_LOGIC      :
                case PALAVRA_RESERVADA_READ       :
                case PALAVRA_RESERVADA_REAL       :
                case PALAVRA_RESERVADA_REPEAT     :
                case PALAVRA_RESERVADA_RESULT     :
                case PALAVRA_RESERVADA_STRING     :
                case PALAVRA_RESERVADA_THIS       :
                case PALAVRA_RESERVADA_TRUE       :
                case PALAVRA_RESERVADA_TYPE       :
                case PALAVRA_RESERVADA_UNTRUE     :
                case PALAVRA_RESERVADA_VARIABLE   :
                case PALAVRA_RESERVADA_WRITE      :
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'PALAVRA-RESERVADA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'PALAVRA-RESERVADA' -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case IDENTIFICADOR:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'IDENTIFICADOR'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'IDENTIFICADOR'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "']\n");
                    break;
                }
                case CONSTANTE_LITERAL:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'CONSTANTE_LITERAL'  -  " + "Id: ['" +  t.kind + "'] - Linha: ['" + t.beginLine + "']  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case CONSTANTE_NUMERICA_INTEIRA:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'CONSTANTE_NUMERICA_INTEIRA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case CONSTANTE_NUMERICA_REAL:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'CONSTANTE_NUMERICA_REAL'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                //Símbolos especiais
                case SIMBOLO_ESPECIAL_ABRE_CHAVES:
                case SIMBOLO_ESPECIAL_FECHA_CHAVES:
                case SIMBOLO_ESPECIAL_PONTO_FINAL:
                case SIMBOLO_ESPECIAL_VIRGULA:
                case SIMBOLO_ESPECIAL_ABRE_COLCHETES:
                case SIMBOLO_ESPECIAL_FECHA_COLCHETES:
                case SIMBOLO_ESPECIAL_ABRE_PARENTESES:
                case SIMBOLO_ESPECIAL_FECHA_PARENTESES:
                //Símbolos aritméticos
                case OPERADOR_ARITMETICO_ADICAO:
                case OPERADOR_ARITMETICO_SUBTRACAO:
                case OPERADOR_ARITMETICO_MULTIPLICACAO:
                case OPERADOR_ARITMETICO_DIVISAO:
                case OPERADOR_ARITMETICO_POTENCIACAO:
                case OPERADOR_ARITMETICO_DIVISAO_INTEIRA:
                case OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA:
                //Símbolos lógicos
                case OPERADOR_RELACIONAL_IGUAL:
                case OPERADOR_RELACIONAL_DIFERENTE:
                case OPERADOR_RELACIONAL_MENOR:
                case OPERADOR_RELACIONAL_MAIOR:
                case OPERADOR_RELACIONAL_MENOR_IGUAL:
                case OPERADOR_RELACIONAL_MAIOR_IGUAL:
                {
                    tokens.append("Token: '" + t.image + "' - Tipo: 'SIMBOLO_ESPECIAL'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Token: ['" + t.image + "'] - Tipo: 'SIMBOLO_ESPECIAL'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    break;
                }
                case SIMBOLO_INVALIDO:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'SIMBOLO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'SIMBOLO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'SIMBOLO_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case CONSTANTE_LITERAL_INVALIDA:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_LITERAL_INVALIDA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case CONSTANTE_NUMERICA_INTEIRA_INVALIDA:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_INTEIRA_INVALIDA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case CONSTANTE_NUMERICA_REAL_INVALIDA:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL_INVALIDA'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'CONSTANTE_NUMERICA_REAL_INVALIDA'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                case COMENTARIO_FACULTATIVO_INVALIDO:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'COMENTARIO_FACULTATIVO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'COMENTARIO_FACULTATIVO_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'COMENTARIO_FACULTATIVO_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                }
                 case IDENTIFICADOR_INVALIDO:
                 {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    contLexicalErrors++;
                    break;
                 }
                /*default:
                {
                    tokens.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    lexicalErrors.append("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "ID: " +  t.kind + " - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    System.out.println("Erro: '" + t.image + "' - Tipo: 'IDENTIFICADOR_INVALIDO'  -  " + "Id: '" +  t.kind + "' - Linha: '" + t.beginLine + "'  -  Coluna: '" + t.beginColumn + "'\n");
                    hasLexicalErrors = true;
                    break;
                }*/
            }
            leituraDeTokens();
        }catch(Error erro){
            hasLexicalErrors = true;
            contLexicalErrors++;
            tokens.append("Erro - " + erro.getMessage() + "\n");
            System.out.println(erro.toString());
            leituraDeTokens();
        }
    }
    public void limpaClasse(){
        tokens = null;
        lexicalErrors = new StringBuilder("");
        hasLexicalErrors = false;
        contLexicalErrors = 0;
        for(int i = 0; i < syntaticsErrors.size() ; i++){
            syntaticsErrors.remove(i);
        }
        debugRecovery = true;
        //eof = null;
        contSyntaticsErrors = 0;

    }
    public String analyze(String[] args, String textToAnalyze) throws ParseException  {
        Language20221 language20221 = this.readInput(args, textToAnalyze);
        StringBuilder errosSintaticos = new StringBuilder("");
        this.leituraDeTokens();
        tokens.append("<EOF>");

        try {
            if(!hasLexicalErrors){
                language20221.begin_program();
            } else {
                return lexicalErrors.toString();
            }
        }catch (ParseException ex) {
            return ex.getMessage().toString();
        }
        if(language20221.getContSyntaticsErrors() > 0){
            /*return "Esse programa possui + " + language20221.getContSyntaticsErrors() +
             //" erros sintaticos: \n" + language20221.getSyntacticErrors();"
             " erros sintaticos: \n" + language20221.getSyntacticErrors();
             //ArrayList<ErrorStruct> output = checkSyntax(textToAnalyze);*/

             /*if (output.size() == 0) {
                 this.errosLexicos.appendText("Compilado com sucesso!\n");
                 return;
             }*/
             errosSintaticos.append("\n");
             errosSintaticos.append(syntaticsErrors.size() + " Erros sintaticos encontrados :\n");
             for (ErrorStruct err: syntaticsErrors){
                 errosSintaticos.append(err.getMsg());
                 errosSintaticos.append("Esperado(s):" + err.expected());
                 errosSintaticos.append("Linha: " + err.getError().currentToken.beginLine);
                 errosSintaticos.append("; Coluna: " + err.getError().currentToken.endColumn + "\n");
             }
             return errosSintaticos.toString();
        }
        errosSintaticos.append("Sintaticamente correto!");
        return errosSintaticos.toString();
    }

        private Language20221 readInput(String args[], String textToAnalyze) {
            Language20221 sintatico = null;
            if(args.length == 0){
                System.out.println("Reading from received text!");
                java.io.InputStream targetStream = new java.io.ByteArrayInputStream(textToAnalyze.getBytes());
                sintatico = new Language20221(targetStream);
            }
            else if(args.length == 1){
                try{
                    sintatico = new Language20221(new java.io.FileInputStream(args[0]));
                }
                catch(java.io.FileNotFoundException e){
                    System.err.println(args[0] + " was not found." );
                    System.err.println(e);
                }
            }
            else{
                System.out.println("Use:\njava Sintatico < inputFile");
                System.out.println("or java Sintatico inputFile");
            }
            return sintatico;
        }

    public String getTokens(String args[], String textoParaAnalisar) {
        Language20221 language20221;
        if(args.length == 0){
            System.out.println("#####################################");
            System.out.println("### Iniciando leitura dos tokens ...");
            System.out.println("#####################################");
            java.io.InputStream targetStream = new java.io.ByteArrayInputStream(textoParaAnalisar.getBytes());
            language20221 = new Language20221(targetStream);
        }else if(args.length == 1){
            try{
                language20221 = new Language20221(new java.io.FileInputStream(args[0]));
            }catch(java.io.FileNotFoundException e){
                System.err.println(args[0] + " n\u00c3\u00a3o foi encontrado." );
                System.err.println(e);
                return args[0] + " n\u00c3\u00a3o foi encontrado.";
            }
        }else{
            System.out.println("Use:\njava Language2021 < inputFile");
            System.out.println("ou java Language2021 inputFile");
            return "Use:java Language2021 < inputFile";
        }
        this.leituraDeTokens();
        tokens.append("<EOF>");
        return tokens.toString();
    }

    public static void main(String args[]) throws TokenMgrError, ParseException {
        Language20221 parser = null;
        if (args.length == 0) {
            parser = new Language20221(System.in);
        }else if (args.length == 1) {
            try {
                parser = new Language20221(new java.io.FileInputStream(args[0]));
            }catch (java.io.FileNotFoundException e) {
                System.out.println("Language20221: file " + args[0] + " was not found.");
                return;
            }
        }
    }

    public static List<Token> getTokens(String stream){
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        Language20221 parser = new Language20221(target);
        return tokenize(parser);
    }

    public static List<Token> tokenize(Language20221 parser){
        List<Token> tokens = new ArrayList<Token>();

        Token token = parser.getNextToken();
        while (token.kind != Language20221Constants.EOF){
            tokens.add(token);
            token = parser.getNextToken();
        }

        if (!TokenHandler.isClosed()){
            tokens.add(TokenHandler.createToken());
        }
        return tokens;
    }

    //VERIFICAR SE AINDA É UTILIZADO
    static public String im(int x){
        String s = tokenImage[x];
        int k = s.lastIndexOf("\"");
        try {
            s = s.substring(1, k);
        }catch (StringIndexOutOfBoundsException e){
        }
        return s;
    }

    public void consumeUntil(RecoverySet g, ParseException e, String met) throws  ParseException {
        Token tok;
        if (g == null){
            throw e;
        }
        tok = getToken(1); // Current token
        while (!eof){
            /* found a token in set */
            if (g.contains(tok.kind)) {
                break;
            }
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && !g.contains(EOF)){
                eof = true;
            }
        }
        contSyntaticsErrors++;
    }

    /*public static ArrayList<ErrorStruct> checkSyntax(String stream) {
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        Language20221 parser = new Language20221(target);
        try {
            parser.begin_program();
        }catch (ParseException e){
            lexicalErrors.add(new ErrorStruct("Error parsing the program.\n", e));
        }
        ArrayList tmp = new ArrayList<ErrorStruct>(lexicalErrors);
        lexicalErrors.clear();
        return tmp;
    }*/

    public String getTokens(){
        return tokens.toString();
    }
    public int getContLexicalErrors(){
        return contLexicalErrors;
    }

    public String getLexicalErrors(){
        return lexicalErrors.toString();
    }

    public int getContSyntaticsErrors() {
        return this.contSyntaticsErrors;
    }

    public String getSyntacticErrors() {
        return this.syntaticsErrors.toString();
    }

    public ErrorStruct getSyntaticErrorsObject(){
        return (ErrorStruct) syntaticsErrors;
    }

  final public void enum_values() throws ParseException {
    trace_call("enum_values");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTANTE_LITERAL:
      case CONSTANTE_NUMERICA_INTEIRA:
      case CONSTANTE_NUMERICA_REAL:
        constant_result();
        break;
      case IDENTIFICADOR:
        jj_consume_token(IDENTIFICADOR);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("enum_values");
    }
  }

  final public void inner_enum_declaration(RecoverySet r) throws ParseException {
    trace_call("inner_enum_declaration");
    try {
      try {
        jj_consume_token(IDENTIFICADOR);
        jj_consume_token(PALAVRA_RESERVADA_IS);
        enum_values();
        inner_enum_decla_cont();
        jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
      } catch (ParseException e) {
           consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
           syntaticsErrors.add(new ErrorStruct("Erro: declaracao de enum interna incorreta.\n", e));
      }
    } finally {
      trace_return("inner_enum_declaration");
    }
  }

  final public void inner_enum_decla_cont() throws ParseException {
    trace_call("inner_enum_decla_cont");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIMBOLO_ESPECIAL_VIRGULA:
        jj_consume_token(SIMBOLO_ESPECIAL_VIRGULA);
        enum_values();
        inner_enum_decla_cont();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
    } finally {
      trace_return("inner_enum_decla_cont");
    }
  }

  final public void enum_declaration(RecoverySet r) throws ParseException {
    trace_call("enum_declaration");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_TYPE);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        label_1:
        while (true) {
          inner_enum_declaration(r);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFICADOR:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_1;
          }
        }
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_DECLARATION:
          jj_consume_token(PALAVRA_RESERVADA_DECLARATION);
          declaration_constants_and_variables(r);
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
      } catch (ParseException e) {
       consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
       syntaticsErrors.add(new ErrorStruct("Erro: declaracao de enum incorreta.\n", e));
      }
    } finally {
      trace_return("enum_declaration");
    }
  }

  final public void identifiers() throws ParseException {
    trace_call("identifiers");
    try {
      jj_consume_token(IDENTIFICADOR);
      index();
    } finally {
      trace_return("identifiers");
    }
  }

  final public void identifiers_list() throws ParseException {
    trace_call("identifiers_list");
    try {
      try {
        identifiers();
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SIMBOLO_ESPECIAL_VIRGULA:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_2;
          }
          jj_consume_token(SIMBOLO_ESPECIAL_VIRGULA);
          identifiers();
        }
      } catch (ParseException e) {
        syntaticsErrors.add(new ErrorStruct("Erro: Lista de identificadores incorreto.\n", e));
      }
    } finally {
      trace_return("identifiers_list");
    }
  }

  final public void type_declaration() throws ParseException {
    trace_call("type_declaration");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PALAVRA_RESERVADA_INTEGER:
        jj_consume_token(PALAVRA_RESERVADA_INTEGER);
        break;
      case PALAVRA_RESERVADA_REAL:
        jj_consume_token(PALAVRA_RESERVADA_REAL);
        break;
      case PALAVRA_RESERVADA_STRING:
        jj_consume_token(PALAVRA_RESERVADA_STRING);
        break;
      case PALAVRA_RESERVADA_LOGIC:
        jj_consume_token(PALAVRA_RESERVADA_LOGIC);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("type_declaration");
    }
  }

  final public void variable_declaration() throws ParseException {
    trace_call("variable_declaration");
    try {
      identifiers_list();
      jj_consume_token(PALAVRA_RESERVADA_IS);
      type_declaration();
      jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
    } finally {
      trace_return("variable_declaration");
    }
  }

  final public void type_constant() throws ParseException {
    trace_call("type_constant");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PALAVRA_RESERVADA_INTEGER:
        jj_consume_token(PALAVRA_RESERVADA_INTEGER);
        break;
      case PALAVRA_RESERVADA_REAL:
        jj_consume_token(PALAVRA_RESERVADA_REAL);
        break;
      case PALAVRA_RESERVADA_STRING:
        jj_consume_token(PALAVRA_RESERVADA_STRING);
        break;
      case PALAVRA_RESERVADA_LOGIC:
        jj_consume_token(PALAVRA_RESERVADA_LOGIC);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("type_constant");
    }
  }

  final public void end_constant() throws ParseException {
    trace_call("end_constant");
    try {
      jj_consume_token(PALAVRA_RESERVADA_AS);
      jj_consume_token(PALAVRA_RESERVADA_CONSTANT);
      label_3:
      while (true) {
        constant_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFICADOR:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
      }
    } finally {
      trace_return("end_constant");
    }
  }

  final public void start_variable() throws ParseException {
    trace_call("start_variable");
    try {
      jj_consume_token(PALAVRA_RESERVADA_VARIABLE);
      label_4:
      while (true) {
        variable_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFICADOR:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_4;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PALAVRA_RESERVADA_AS:
        end_constant();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
    } finally {
      trace_return("start_variable");
    }
  }

  final public void constant_declaration() throws ParseException {
    trace_call("constant_declaration");
    try {
      identifiers_list();
      jj_consume_token(PALAVRA_RESERVADA_IS);
      type_constant();
      jj_consume_token(OPERADOR_ATRIBUICAO);
      constant_result();
      jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
    } finally {
      trace_return("constant_declaration");
    }
  }

  final public void end_variable() throws ParseException {
    trace_call("end_variable");
    try {
      jj_consume_token(PALAVRA_RESERVADA_AS);
      jj_consume_token(PALAVRA_RESERVADA_VARIABLE);
      label_5:
      while (true) {
        variable_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFICADOR:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
      }
    } finally {
      trace_return("end_variable");
    }
  }

  final public void start_constant() throws ParseException {
    trace_call("start_constant");
    try {
      jj_consume_token(PALAVRA_RESERVADA_CONSTANT);
      label_6:
      while (true) {
        constant_declaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFICADOR:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PALAVRA_RESERVADA_AS:
        end_variable();
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
    } finally {
      trace_return("start_constant");
    }
  }

  final public void start_declaration(RecoverySet r) throws ParseException {
    trace_call("start_declaration");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_VARIABLE:
          start_variable();
          break;
        case PALAVRA_RESERVADA_CONSTANT:
          start_constant();
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
         consumeUntil(r, e, "Error: Invalid declaration body.\n");
         syntaticsErrors.add(new ErrorStruct("Erro: Declaracao de variavel/constante errado.\n", e));
      }
    } finally {
      trace_return("start_declaration");
    }
  }

  final public void inner_declaration(RecoverySet r) throws ParseException {
    trace_call("inner_declaration");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_AS);
        start_declaration(r);
      } catch (ParseException e) {
        consumeUntil(r, e, "Error: Invalid declaration body.\n");
        syntaticsErrors.add(new ErrorStruct("Error: Bad inner declaration of as.\n", e));
      }
    } finally {
      trace_return("inner_declaration");
    }
  }

  final public void declaration_constants_and_variables(RecoverySet r) throws ParseException {
    trace_call("declaration_constants_and_variables");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_CONSTANT);
        jj_consume_token(PALAVRA_RESERVADA_AND);
        jj_consume_token(PALAVRA_RESERVADA_VARIABLE);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        inner_declaration(r);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      } catch (ParseException e) {
        consumeUntil(r, e, "declaration_constants_and_variables");
        syntaticsErrors.add(new ErrorStruct("Error: Forma geral de declaracao de constante e variaval incorreta.\n", e));
      }
    } finally {
      trace_return("declaration_constants_and_variables");
    }
  }

  final public void constant_result() throws ParseException {
    trace_call("constant_result");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTANTE_LITERAL:
        jj_consume_token(CONSTANTE_LITERAL);
        break;
      case CONSTANTE_NUMERICA_INTEIRA:
        jj_consume_token(CONSTANTE_NUMERICA_INTEIRA);
        break;
      case CONSTANTE_NUMERICA_REAL:
        jj_consume_token(CONSTANTE_NUMERICA_REAL);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("constant_result");
    }
  }

  final public void logic_result(RecoverySet r) throws ParseException {
    trace_call("logic_result");
    try {
                                     RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_TRUE:
          jj_consume_token(PALAVRA_RESERVADA_TRUE);
          jj_consume_token(PALAVRA_RESERVADA_RESULT);
          jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
          list_of_commands(g);
          jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
          true_result_cont();
          break;
        case PALAVRA_RESERVADA_UNTRUE:
          jj_consume_token(PALAVRA_RESERVADA_UNTRUE);
          jj_consume_token(PALAVRA_RESERVADA_RESULT);
          jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
          list_of_commands(g);
          jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
          untrue_result_cont();
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        consumeUntil(r, e, "");
        syntaticsErrors.add(new ErrorStruct("Erro: Verificacao de resultado logico incorreto.\n", e));
      }
    } finally {
      trace_return("logic_result");
    }
  }

  final public void true_result_cont() throws ParseException {
    trace_call("true_result_cont");
    try {
                           RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_UNTRUE:
          jj_consume_token(PALAVRA_RESERVADA_UNTRUE);
          jj_consume_token(PALAVRA_RESERVADA_RESULT);
          jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
          list_of_commands(g);
          jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
          jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
          break;
        case SIMBOLO_ESPECIAL_PONTO_FINAL:
          jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        consumeUntil(g, e, "list_of_commands");
        syntaticsErrors.add(new ErrorStruct("Erro: Clausula de teste incorreta.\n", e));
      }
    } finally {
      trace_return("true_result_cont");
    }
  }

  final public void untrue_result_cont() throws ParseException {
    trace_call("untrue_result_cont");
    try {
                             RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_TRUE:
          jj_consume_token(PALAVRA_RESERVADA_TRUE);
          jj_consume_token(PALAVRA_RESERVADA_RESULT);
          jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
          list_of_commands(g);
          jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
          jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
          break;
        case SIMBOLO_ESPECIAL_PONTO_FINAL:
          jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        consumeUntil(g, e, "");
        syntaticsErrors.add(new ErrorStruct("Erro: Clausula de teste incorreta.\n", e));
      }
    } finally {
      trace_return("untrue_result_cont");
    }
  }

  final public void declarations(RecoverySet r) throws ParseException {
    trace_call("declarations");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_DECLARATION:
          jj_consume_token(PALAVRA_RESERVADA_DECLARATION);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PALAVRA_RESERVADA_TYPE:
            enum_declaration(r);
            break;
          case PALAVRA_RESERVADA_CONSTANT:
            declaration_constants_and_variables(r);
            break;
          default:
            jj_la1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        consumeUntil(r, e, "declarations");
        syntaticsErrors.add(new ErrorStruct("Erro de declaracao de enum/variable\n", e));
      }
    } finally {
      trace_return("declarations");
    }
  }

  final public void list_of_commands(RecoverySet r) throws ParseException {
    trace_call("list_of_commands");
    try {
                                        RecoverySet g = First.list_of_commands ;
      try {
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PALAVRA_RESERVADA_REPEAT:
            repeat(g);
            break;
          case PALAVRA_RESERVADA_AVALIATE:
            avaliate(g);
            break;
          case PALAVRA_RESERVADA_WRITE:
            jj_consume_token(PALAVRA_RESERVADA_WRITE);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case PALAVRA_RESERVADA_THIS:
              write(g);
              break;
            case PALAVRA_RESERVADA_ALL:
              write_all(g);
              break;
            default:
              jj_la1[20] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          case PALAVRA_RESERVADA_DESIGNATE:
            designate(g);
            break;
          case PALAVRA_RESERVADA_READ:
            read(g);
            break;
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PALAVRA_RESERVADA_AVALIATE:
          case PALAVRA_RESERVADA_DESIGNATE:
          case PALAVRA_RESERVADA_READ:
          case PALAVRA_RESERVADA_REPEAT:
          case PALAVRA_RESERVADA_WRITE:
            ;
            break;
          default:
            jj_la1[22] = jj_gen;
            break label_7;
          }
        }
      } catch (ParseException e) {
        consumeUntil(r, e, "list_of_commands");
        syntaticsErrors.add(new ErrorStruct("Erro: Declaracao de comando incorreta.\n", e));
      }
    } finally {
      trace_return("list_of_commands");
    }
  }

  final public void expression(RecoverySet g) throws ParseException {
    trace_call("expression");
    try {
      try {
        arithmetic_or_logic_expression(g);
        expression_cont(g);
      } catch (ParseException e) {
       consumeUntil(g, e, "list_of_commands");
       syntaticsErrors.add(new ErrorStruct("Erro: Expressao incorreta.\n", e));
      }
    } finally {
      trace_return("expression");
    }
  }

  final public void arithmetic_or_logic_expression(RecoverySet g) throws ParseException {
    trace_call("arithmetic_or_logic_expression");
    try {
      second_term(g);
      lesser_priority_operators(g);
    } finally {
      trace_return("arithmetic_or_logic_expression");
    }
  }

  final public void expression_cont(RecoverySet g) throws ParseException {
    trace_call("expression_cont");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERADOR_RELACIONAL_IGUAL:
      case OPERADOR_RELACIONAL_DIFERENTE:
      case OPERADOR_RELACIONAL_MENOR:
      case OPERADOR_RELACIONAL_MAIOR:
      case OPERADOR_RELACIONAL_MENOR_IGUAL:
      case OPERADOR_RELACIONAL_MAIOR_IGUAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERADOR_RELACIONAL_IGUAL:
          jj_consume_token(OPERADOR_RELACIONAL_IGUAL);
          arithmetic_or_logic_expression(g);
          break;
        case OPERADOR_RELACIONAL_DIFERENTE:
          jj_consume_token(OPERADOR_RELACIONAL_DIFERENTE);
          arithmetic_or_logic_expression(g);
          break;
        case OPERADOR_RELACIONAL_MENOR:
          jj_consume_token(OPERADOR_RELACIONAL_MENOR);
          arithmetic_or_logic_expression(g);
          break;
        case OPERADOR_RELACIONAL_MAIOR:
          jj_consume_token(OPERADOR_RELACIONAL_MAIOR);
          arithmetic_or_logic_expression(g);
          break;
        case OPERADOR_RELACIONAL_MENOR_IGUAL:
          jj_consume_token(OPERADOR_RELACIONAL_MENOR_IGUAL);
          arithmetic_or_logic_expression(g);
          break;
        case OPERADOR_RELACIONAL_MAIOR_IGUAL:
          jj_consume_token(OPERADOR_RELACIONAL_MAIOR_IGUAL);
          arithmetic_or_logic_expression(g);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
    } finally {
      trace_return("expression_cont");
    }
  }

  final public void first_term(RecoverySet g) throws ParseException {
    trace_call("first_term");
    try {
      element(g);
      top_priority_operators(g);
    } finally {
      trace_return("first_term");
    }
  }

  final public void second_term(RecoverySet g) throws ParseException {
    trace_call("second_term");
    try {
      first_term(g);
      medium_priority_operators(g);
    } finally {
      trace_return("second_term");
    }
  }

  final public void element(RecoverySet g) throws ParseException {
    trace_call("element");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFICADOR:
        jj_consume_token(IDENTIFICADOR);
        index();
        break;
      case CONSTANTE_NUMERICA_INTEIRA:
        jj_consume_token(CONSTANTE_NUMERICA_INTEIRA);
        break;
      case CONSTANTE_NUMERICA_REAL:
        jj_consume_token(CONSTANTE_NUMERICA_REAL);
        break;
      case CONSTANTE_LITERAL:
        jj_consume_token(CONSTANTE_LITERAL);
        break;
      case PALAVRA_RESERVADA_TRUE:
        jj_consume_token(PALAVRA_RESERVADA_TRUE);
        break;
      case PALAVRA_RESERVADA_UNTRUE:
        jj_consume_token(PALAVRA_RESERVADA_UNTRUE);
        break;
      case SIMBOLO_ESPECIAL_ABRE_PARENTESES:
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_PARENTESES);
        expression(g);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_PARENTESES);
        break;
      case OPERADOR_LOGICO_NAO:
        jj_consume_token(OPERADOR_LOGICO_NAO);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_PARENTESES);
        expression(g);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_PARENTESES);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("element");
    }
  }

  final public void index() throws ParseException {
    trace_call("index");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIMBOLO_ESPECIAL_ABRE_CHAVES:
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_CHAVES);
        jj_consume_token(CONSTANTE_NUMERICA_INTEIRA);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_CHAVES);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } finally {
      trace_return("index");
    }
  }

  final public void top_priority_operators(RecoverySet g) throws ParseException {
    trace_call("top_priority_operators");
    try {
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERADOR_ARITMETICO_POTENCIACAO:
          ;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_8;
        }
        jj_consume_token(OPERADOR_ARITMETICO_POTENCIACAO);
        element(g);
      }
    } finally {
      trace_return("top_priority_operators");
    }
  }

  final public void medium_priority_operators(RecoverySet g) throws ParseException {
    trace_call("medium_priority_operators");
    try {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERADOR_ARITMETICO_MULTIPLICACAO:
        case OPERADOR_ARITMETICO_DIVISAO:
        case OPERADOR_ARITMETICO_DIVISAO_INTEIRA:
        case OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA:
        case OPERADOR_LOGICO_E:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERADOR_ARITMETICO_MULTIPLICACAO:
          jj_consume_token(OPERADOR_ARITMETICO_MULTIPLICACAO);
          first_term(g);
          break;
        case OPERADOR_ARITMETICO_DIVISAO:
          jj_consume_token(OPERADOR_ARITMETICO_DIVISAO);
          first_term(g);
          break;
        case OPERADOR_ARITMETICO_DIVISAO_INTEIRA:
          jj_consume_token(OPERADOR_ARITMETICO_DIVISAO_INTEIRA);
          first_term(g);
          break;
        case OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA:
          jj_consume_token(OPERADOR_ARITMETICO_RESTO_DIVISAO_INTEIRA);
          first_term(g);
          break;
        case OPERADOR_LOGICO_E:
          jj_consume_token(OPERADOR_LOGICO_E);
          first_term(g);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("medium_priority_operators");
    }
  }

  final public void lesser_priority_operators(RecoverySet g) throws ParseException {
    trace_call("lesser_priority_operators");
    try {
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERADOR_ARITMETICO_ADICAO:
        case OPERADOR_ARITMETICO_SUBTRACAO:
        case OPERADOR_LOGICO_OU:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_10;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERADOR_ARITMETICO_ADICAO:
          jj_consume_token(OPERADOR_ARITMETICO_ADICAO);
          second_term(g);
          break;
        case OPERADOR_ARITMETICO_SUBTRACAO:
          jj_consume_token(OPERADOR_ARITMETICO_SUBTRACAO);
          second_term(g);
          break;
        case OPERADOR_LOGICO_OU:
          jj_consume_token(OPERADOR_LOGICO_OU);
          second_term(g);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("lesser_priority_operators");
    }
  }

  final public void repeat(RecoverySet r) throws ParseException {
    trace_call("repeat");
    try {
        RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        RecoverySet h = new RecoverySet(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      try {
        jj_consume_token(PALAVRA_RESERVADA_REPEAT);
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        expression(g);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        list_of_commands(h);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
        jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
      } catch (ParseException e) {
       consumeUntil(r, e, "");
       syntaticsErrors.add(new ErrorStruct("Erro: Declaracao do comando repeat incorreta. \n", e));
      }
    } finally {
      trace_return("repeat");
    }
  }

  final public void avaliate(RecoverySet r) throws ParseException {
    trace_call("avaliate");
    try {
                                RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_PONTO_FINAL);
      try {
        jj_consume_token(PALAVRA_RESERVADA_AVALIATE);
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        expression(First.selection_command);
        logic_result(g);
      } catch (ParseException e) {
           consumeUntil(r, e, "");
           syntaticsErrors.add(new ErrorStruct("Erro: Declaracao do comando avaliate incorreta. \n", e));
      }
    } finally {
      trace_return("avaliate");
    }
  }

  final public void write(RecoverySet g) throws ParseException {
    trace_call("write");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        write_body();
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
        jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
      } catch (ParseException e) {
        consumeUntil(g, e, "list_of_commands");
        syntaticsErrors.add(new ErrorStruct("Erro: Comando write incorreto.\n", e));
      }
    } finally {
      trace_return("write");
    }
  }

  final public void write_all(RecoverySet g) throws ParseException {
    trace_call("write_all");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_ALL);
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        write_body();
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
        jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
      } catch (ParseException e) {
       consumeUntil(g, e, "");
       syntaticsErrors.add(new ErrorStruct("Erro: no comando write all.\n", e));
      }
    } finally {
      trace_return("write_all");
    }
  }

  final public void write_body() throws ParseException {
    trace_call("write_body");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONSTANTE_LITERAL:
        case CONSTANTE_NUMERICA_INTEIRA:
        case CONSTANTE_NUMERICA_REAL:
          constant_result();
          label_11:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIMBOLO_ESPECIAL_VIRGULA:
              ;
              break;
            default:
              jj_la1[32] = jj_gen;
              break label_11;
            }
            jj_consume_token(SIMBOLO_ESPECIAL_VIRGULA);
            write_body_cont();
          }
          break;
        case IDENTIFICADOR:
          identifiers();
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIMBOLO_ESPECIAL_VIRGULA:
              ;
              break;
            default:
              jj_la1[33] = jj_gen;
              break label_12;
            }
            jj_consume_token(SIMBOLO_ESPECIAL_VIRGULA);
            write_body_cont();
          }
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
       syntaticsErrors.add(new ErrorStruct("Erro: Erro no corpo do write.\n", e));
      }
    } finally {
      trace_return("write_body");
    }
  }

  final public void write_body_cont() throws ParseException {
    trace_call("write_body_cont");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONSTANTE_LITERAL:
        case CONSTANTE_NUMERICA_INTEIRA:
        case CONSTANTE_NUMERICA_REAL:
          constant_result();
          break;
        case IDENTIFICADOR:
          identifiers();
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        syntaticsErrors.add(new ErrorStruct("Erro: Erro no corpo do write.\n", e));
      }
    } finally {
      trace_return("write_body_cont");
    }
  }

  final public void designate(RecoverySet r) throws ParseException {
    trace_call("designate");
    try {
                                 RecoverySet h = new RecoverySet(SIMBOLO_ESPECIAL_PONTO_FINAL);
      try {
        jj_consume_token(PALAVRA_RESERVADA_DESIGNATE);
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        identifiers_list();
        jj_consume_token(PALAVRA_RESERVADA_AS);
        expression(h);
        jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
      } catch (ParseException e) {
       consumeUntil(r, e, "");
       syntaticsErrors.add(new ErrorStruct("Erro: Erro de atribuicao (designate).\n", e));
      }
    } finally {
      trace_return("designate");
    }
  }

  final public void read(RecoverySet r) throws ParseException {
    trace_call("read");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_READ);
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        identifiers_list();
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
        jj_consume_token(SIMBOLO_ESPECIAL_PONTO_FINAL);
      } catch (ParseException e) {
        consumeUntil(r, e, "read");
      }
    } finally {
      trace_return("read");
    }
  }

  final public void header(RecoverySet r) throws ParseException {
    trace_call("header");
    try {
      try {
        jj_consume_token(PALAVRA_RESERVADA_DO);
        jj_consume_token(PALAVRA_RESERVADA_THIS);
        jj_consume_token(IDENTIFICADOR);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      } catch (ParseException e) {
        consumeUntil(r, e, "header");
        syntaticsErrors.add(new ErrorStruct("Erro: Cabecalho principal incorreto.\n", e));
      }
    } finally {
      trace_return("header");
    }
  }

  final public void body(RecoverySet r) throws ParseException {
    trace_call("body");
    try {
                            RecoverySet g = new RecoverySet(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
      try {
        jj_consume_token(PALAVRA_RESERVADA_BODY);
        jj_consume_token(SIMBOLO_ESPECIAL_ABRE_COLCHETES);
        list_of_commands(g);
        jj_consume_token(SIMBOLO_ESPECIAL_FECHA_COLCHETES);
      } catch (ParseException e) {
        consumeUntil(r, e, "body");
        syntaticsErrors.add(new ErrorStruct("Erro: Declaracao do corpo incorreto.\n", e));
      }
    } finally {
      trace_return("body");
    }
  }

  final public void desc(RecoverySet r) throws ParseException {
    trace_call("desc");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_DESCRIPTION:
          jj_consume_token(PALAVRA_RESERVADA_DESCRIPTION);
          jj_consume_token(CONSTANTE_LITERAL);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        consumeUntil(r, e, "description");
        syntaticsErrors.add(new ErrorStruct("Erro: Descricao do programa incorreto\n", e));
      }
    } finally {
      trace_return("desc");
    }
  }

  final public void main(RecoverySet r) throws ParseException {
    trace_call("main");
    try {
        RecoverySet h = new RecoverySet(PALAVRA_RESERVADA_BODY);
        RecoverySet g = new RecoverySet(PALAVRA_RESERVADA_DECLARATION);
        RecoverySet i = g.union(h);
        RecoverySet l = new RecoverySet(PALAVRA_RESERVADA_DESCRIPTION);
      try {
        header(i);
        declarations(h);
        body(r.union(l));
        desc(r);
      } catch (ParseException e) {
        consumeUntil(r, e, "main");
      }
    } finally {
      trace_return("main");
    }
  }

  final public void begin_program() throws ParseException {
    trace_call("begin_program");
    try {
                        RecoverySet r = new RecoverySet(EOF);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PALAVRA_RESERVADA_DO:
          main(r);
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        jj_consume_token(0);
      } catch (ParseException e) {
        consumeUntil(r, e, "begin_program");
        syntaticsErrors.add(new ErrorStruct("Erro: Forma geral do programa incorreto.\n", e));
      }
    } finally {
      trace_return("begin_program");
    }
  }

  /** Generated Token Manager. */
  public Language20221TokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[38];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x4000,0x0,0x2540000,0x2540000,0x0,0x0,0x400,0x0,0x0,0x400,0x40002000,0x0,0x28000000,0x20000000,0x8000000,0x10002000,0x4000,0x4000100,0x80a10800,0x80a10800,0x0,0x0,0x28000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x20000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1640,0x10000,0x40,0x0,0x10000,0x0,0x0,0x40,0x40,0x0,0x40,0x40,0x0,0x0,0x1600,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0xf0000000,0xf0000000,0x81640,0x2000,0x2000000,0xd800000,0xd800000,0x600000,0x600000,0x10000,0x10000,0x1640,0x1640,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x10,0x0,0x0,0x4,0x4,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public Language20221(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Language20221(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new Language20221TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Language20221(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new Language20221TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Language20221(Language20221TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(Language20221TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[76];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 38; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 76; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
